<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Coupled Local Functions (CLF): clf::SupportPoint Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Coupled Local Functions (CLF)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceclf.html">clf</a></li><li class="navelem"><a class="el" href="classclf_1_1SupportPoint.html">SupportPoint</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classclf_1_1SupportPoint-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">clf::SupportPoint Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The local function \(\ell_{\hat{x}}\) associated with a support point \(\hat{x}\).  
 <a href="classclf_1_1SupportPoint.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="SupportPoint_8hpp_source.html">SupportPoint.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for clf::SupportPoint:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classclf_1_1SupportPoint.png" usemap="#clf::SupportPoint_map" alt=""/>
  <map id="clf::SupportPoint_map" name="clf::SupportPoint_map">
<area href="classclf_1_1Point.html" title="A generic point in the domain." alt="clf::Point" shape="rect" coords="0,0,272,24"/>
<area href="classclf_1_1CoupledSupportPoint.html" title="A clf::CoupledSupportPoint is a child of clf::SupportPoint, but its cost function couples it with its..." alt="clf::CoupledSupportPoint" shape="rect" coords="141,112,413,136"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acb659eeca56a870923457dcf7303c62d"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1SupportPoint.html#acb659eeca56a870923457dcf7303c62d">~SupportPoint</a> ()=default</td></tr>
<tr class="separator:acb659eeca56a870923457dcf7303c62d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea8bbccebd2f1c88e7c5baabaf4842a1"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1SupportPoint.html#aea8bbccebd2f1c88e7c5baabaf4842a1">NearestNeighborKernel</a> () const</td></tr>
<tr class="memdesc:aea8bbccebd2f1c88e7c5baabaf4842a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The nearest neighbor kernel at each neighboring support point.  <a href="classclf_1_1SupportPoint.html#aea8bbccebd2f1c88e7c5baabaf4842a1">More...</a><br /></td></tr>
<tr class="separator:aea8bbccebd2f1c88e7c5baabaf4842a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b7fc5c3c2e034c6f52790fd56469f33"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1SupportPoint.html#a6b7fc5c3c2e034c6f52790fd56469f33">NearestNeighborKernel</a> (std::size_t const ind) const</td></tr>
<tr class="memdesc:a6b7fc5c3c2e034c6f52790fd56469f33"><td class="mdescLeft">&#160;</td><td class="mdescRight">The nearest neighbor kernel at the \(j^{th}\) closest support point.  <a href="classclf_1_1SupportPoint.html#a6b7fc5c3c2e034c6f52790fd56469f33">More...</a><br /></td></tr>
<tr class="separator:a6b7fc5c3c2e034c6f52790fd56469f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8a95d7f165808dbea4d7e6dcf37cdea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1SupportPoint.html#ae8a95d7f165808dbea4d7e6dcf37cdea">SetNearestNeighbors</a> (std::shared_ptr&lt; const <a class="el" href="classclf_1_1SupportPointCloud.html">SupportPointCloud</a> &gt; const &amp;newcloud, std::vector&lt; unsigned int &gt; const &amp;neighInd, std::vector&lt; double &gt; const &amp;neighDist)</td></tr>
<tr class="memdesc:ae8a95d7f165808dbea4d7e6dcf37cdea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the nearest neighbors.  <a href="classclf_1_1SupportPoint.html#ae8a95d7f165808dbea4d7e6dcf37cdea">More...</a><br /></td></tr>
<tr class="separator:ae8a95d7f165808dbea4d7e6dcf37cdea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca855c8d98dcdec45759ebdb81d1d5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1SupportPoint.html#a1ca855c8d98dcdec45759ebdb81d1d5b">CreateCoupledCosts</a> ()</td></tr>
<tr class="memdesc:a1ca855c8d98dcdec45759ebdb81d1d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the coupled cost functions.  <a href="classclf_1_1SupportPoint.html#a1ca855c8d98dcdec45759ebdb81d1d5b">More...</a><br /></td></tr>
<tr class="separator:a1ca855c8d98dcdec45759ebdb81d1d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a206938b979c66f0d8a8c76f661bd5824"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::size_t &gt; const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1SupportPoint.html#a206938b979c66f0d8a8c76f661bd5824">GlobalNeighborIndices</a> () const</td></tr>
<tr class="memdesc:a206938b979c66f0d8a8c76f661bd5824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the global indices of this support points nearest neighbors.  <a href="classclf_1_1SupportPoint.html#a206938b979c66f0d8a8c76f661bd5824">More...</a><br /></td></tr>
<tr class="separator:a206938b979c66f0d8a8c76f661bd5824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab7875c1409ca60d34b64f5516a4c8a0"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1SupportPoint.html#aab7875c1409ca60d34b64f5516a4c8a0">GlobalIndex</a> () const</td></tr>
<tr class="memdesc:aab7875c1409ca60d34b64f5516a4c8a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the global index of this support point.  <a href="classclf_1_1SupportPoint.html#aab7875c1409ca60d34b64f5516a4c8a0">More...</a><br /></td></tr>
<tr class="separator:aab7875c1409ca60d34b64f5516a4c8a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee09ce5052201f542fe0b9477fa85254"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1SupportPoint.html#aee09ce5052201f542fe0b9477fa85254">LocalIndex</a> (std::size_t const globalInd) const</td></tr>
<tr class="memdesc:aee09ce5052201f542fe0b9477fa85254"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local index given the global index.  <a href="classclf_1_1SupportPoint.html#aee09ce5052201f542fe0b9477fa85254">More...</a><br /></td></tr>
<tr class="separator:aee09ce5052201f542fe0b9477fa85254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e6957194b6ad852c3c5d1674b56b5e4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1SupportPoint.html#a5e6957194b6ad852c3c5d1674b56b5e4">IsNeighbor</a> (std::size_t const &amp;globalInd) const</td></tr>
<tr class="memdesc:a5e6957194b6ad852c3c5d1674b56b5e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a point (indexed by a global ID) is a nearest neighbor.  <a href="classclf_1_1SupportPoint.html#a5e6957194b6ad852c3c5d1674b56b5e4">More...</a><br /></td></tr>
<tr class="separator:a5e6957194b6ad852c3c5d1674b56b5e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe0c7915a3b57b77012917b3ef962be6"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1SupportPoint.html#afe0c7915a3b57b77012917b3ef962be6">NumCoefficients</a> () const</td></tr>
<tr class="memdesc:afe0c7915a3b57b77012917b3ef962be6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of coefficients associated with this support point.  <a href="classclf_1_1SupportPoint.html#afe0c7915a3b57b77012917b3ef962be6">More...</a><br /></td></tr>
<tr class="separator:afe0c7915a3b57b77012917b3ef962be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1980764818adc66f28bfbbe91721b184"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1SupportPoint.html#a1980764818adc66f28bfbbe91721b184">MinimizeUncoupledCost</a> (boost::property_tree::ptree const &amp;options)</td></tr>
<tr class="memdesc:a1980764818adc66f28bfbbe91721b184"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimize the uncoupled cost function (see <a class="el" href="classclf_1_1UncoupledCost.html" title="Compute the uncoupled cost associated with the support point at .">clf::UncoupledCost</a>) for this support point.  <a href="classclf_1_1SupportPoint.html#a1980764818adc66f28bfbbe91721b184">More...</a><br /></td></tr>
<tr class="separator:a1980764818adc66f28bfbbe91721b184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af66449cf9a9cb3c866f0349253cd1546"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1SupportPoint.html#af66449cf9a9cb3c866f0349253cd1546">MinimizeUncoupledCost</a> (Eigen::MatrixXd const &amp;forcing, boost::property_tree::ptree const &amp;options)</td></tr>
<tr class="memdesc:af66449cf9a9cb3c866f0349253cd1546"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimize the uncoupled cost function (see <a class="el" href="classclf_1_1UncoupledCost.html" title="Compute the uncoupled cost associated with the support point at .">clf::UncoupledCost</a>) for this support point.  <a href="classclf_1_1SupportPoint.html#af66449cf9a9cb3c866f0349253cd1546">More...</a><br /></td></tr>
<tr class="separator:af66449cf9a9cb3c866f0349253cd1546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae45ffa377b72628b8cf92fb1e5add6e6"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classclf_1_1SupportPoint.html">SupportPoint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1SupportPoint.html#ae45ffa377b72628b8cf92fb1e5add6e6">NearestNeighbor</a> (std::size_t const jnd) const</td></tr>
<tr class="memdesc:ae45ffa377b72628b8cf92fb1e5add6e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The support point associated with the \(j^{th}\) nearest neighbor.  <a href="classclf_1_1SupportPoint.html#ae45ffa377b72628b8cf92fb1e5add6e6">More...</a><br /></td></tr>
<tr class="separator:ae45ffa377b72628b8cf92fb1e5add6e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd19083fb31ceeb7ddd76c918d49c64e"><td class="memItemLeft" align="right" valign="top">virtual Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1SupportPoint.html#afd19083fb31ceeb7ddd76c918d49c64e">Operator</a> () const override</td></tr>
<tr class="memdesc:afd19083fb31ceeb7ddd76c918d49c64e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the operator applied to the local function at the support point location.  <a href="classclf_1_1SupportPoint.html#afd19083fb31ceeb7ddd76c918d49c64e">More...</a><br /></td></tr>
<tr class="separator:afd19083fb31ceeb7ddd76c918d49c64e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5137423307ce0f7bcb33b3f4732c978"><td class="memItemLeft" align="right" valign="top">virtual Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1SupportPoint.html#aa5137423307ce0f7bcb33b3f4732c978">Operator</a> (Eigen::VectorXd const &amp;loc) const override</td></tr>
<tr class="memdesc:aa5137423307ce0f7bcb33b3f4732c978"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the operator applied to the local function at a given point using the stored coefficients.  <a href="classclf_1_1SupportPoint.html#aa5137423307ce0f7bcb33b3f4732c978">More...</a><br /></td></tr>
<tr class="separator:aa5137423307ce0f7bcb33b3f4732c978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b9d412c1e2de492eca147aea8b2a1e"><td class="memItemLeft" align="right" valign="top">virtual Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1SupportPoint.html#a27b9d412c1e2de492eca147aea8b2a1e">Operator</a> (Eigen::VectorXd const &amp;loc, Eigen::VectorXd const &amp;coeffs) const override</td></tr>
<tr class="memdesc:a27b9d412c1e2de492eca147aea8b2a1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the operator applied to the local function at a given point.  <a href="classclf_1_1SupportPoint.html#a27b9d412c1e2de492eca147aea8b2a1e">More...</a><br /></td></tr>
<tr class="separator:a27b9d412c1e2de492eca147aea8b2a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a605d391f300a254bee2b79eca49edefc"><td class="memItemLeft" align="right" valign="top">virtual Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1SupportPoint.html#a605d391f300a254bee2b79eca49edefc">OperatorJacobian</a> () const override</td></tr>
<tr class="memdesc:a605d391f300a254bee2b79eca49edefc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the Jacobian of the operator applied to the local function at the point's location with the stored coefficients.  <a href="classclf_1_1SupportPoint.html#a605d391f300a254bee2b79eca49edefc">More...</a><br /></td></tr>
<tr class="separator:a605d391f300a254bee2b79eca49edefc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b3943dd78015f0e28b85cbee4e1353f"><td class="memItemLeft" align="right" valign="top">virtual Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1SupportPoint.html#a4b3943dd78015f0e28b85cbee4e1353f">OperatorJacobian</a> (Eigen::VectorXd const &amp;loc) const override</td></tr>
<tr class="memdesc:a4b3943dd78015f0e28b85cbee4e1353f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the Jacobian of the operator applied to the local function at a given point with the stored coefficients.  <a href="classclf_1_1SupportPoint.html#a4b3943dd78015f0e28b85cbee4e1353f">More...</a><br /></td></tr>
<tr class="separator:a4b3943dd78015f0e28b85cbee4e1353f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4ca8c2bc8cc6fc28dc60b10d560bb31"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1SupportPoint.html#ae4ca8c2bc8cc6fc28dc60b10d560bb31">OperatorJacobian</a> (Eigen::VectorXd const &amp;loc, Eigen::VectorXd const &amp;coeffs) const</td></tr>
<tr class="memdesc:ae4ca8c2bc8cc6fc28dc60b10d560bb31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the Jacobian of the operator applied to the local function at a given point.  <a href="classclf_1_1SupportPoint.html#ae4ca8c2bc8cc6fc28dc60b10d560bb31">More...</a><br /></td></tr>
<tr class="separator:ae4ca8c2bc8cc6fc28dc60b10d560bb31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a891889c998d507d6feea605889dd8f60"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; Eigen::MatrixXd &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1SupportPoint.html#a891889c998d507d6feea605889dd8f60">OperatorHessian</a> () const override</td></tr>
<tr class="memdesc:a891889c998d507d6feea605889dd8f60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the Hessian of the operator applied to the local function at a given point.  <a href="classclf_1_1SupportPoint.html#a891889c998d507d6feea605889dd8f60">More...</a><br /></td></tr>
<tr class="separator:a891889c998d507d6feea605889dd8f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d0f583841d7489ce58e6b7161b51d55"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; Eigen::MatrixXd &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1SupportPoint.html#a7d0f583841d7489ce58e6b7161b51d55">OperatorHessian</a> (Eigen::VectorXd const &amp;loc) const override</td></tr>
<tr class="memdesc:a7d0f583841d7489ce58e6b7161b51d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the Hessian of the operator applied to the local function at a given point.  <a href="classclf_1_1SupportPoint.html#a7d0f583841d7489ce58e6b7161b51d55">More...</a><br /></td></tr>
<tr class="separator:a7d0f583841d7489ce58e6b7161b51d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac16ebf6587080a69b3c13c1d23442dde"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; Eigen::MatrixXd &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1SupportPoint.html#ac16ebf6587080a69b3c13c1d23442dde">OperatorHessian</a> (Eigen::VectorXd const &amp;loc, Eigen::VectorXd const &amp;<a class="el" href="classclf_1_1SupportPoint.html#acafae79b49e95205ba32b38c8b66faa5">coefficients</a>) const override</td></tr>
<tr class="memdesc:ac16ebf6587080a69b3c13c1d23442dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the Hessian of the operator applied to the local function at a given point.  <a href="classclf_1_1SupportPoint.html#ac16ebf6587080a69b3c13c1d23442dde">More...</a><br /></td></tr>
<tr class="separator:ac16ebf6587080a69b3c13c1d23442dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8310de0c4f8aac473d8c4b6fbd996cb"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="classclf_1_1BasisFunctions.html">BasisFunctions</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1SupportPoint.html#aa8310de0c4f8aac473d8c4b6fbd996cb">GetBasisFunctions</a> () const</td></tr>
<tr class="memdesc:aa8310de0c4f8aac473d8c4b6fbd996cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the basis function.  <a href="classclf_1_1SupportPoint.html#aa8310de0c4f8aac473d8c4b6fbd996cb">More...</a><br /></td></tr>
<tr class="separator:aa8310de0c4f8aac473d8c4b6fbd996cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49afd98d9fbee487188b40fa818d84cb"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1SupportPoint.html#a49afd98d9fbee487188b40fa818d84cb">NumNeighbors</a> () const</td></tr>
<tr class="memdesc:a49afd98d9fbee487188b40fa818d84cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of nearest neighbors.  <a href="classclf_1_1SupportPoint.html#a49afd98d9fbee487188b40fa818d84cb">More...</a><br /></td></tr>
<tr class="separator:a49afd98d9fbee487188b40fa818d84cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47da5b59500260002791434098105bfc"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Eigen::VectorXd &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1SupportPoint.html#a47da5b59500260002791434098105bfc">EvaluateBasisFunctions</a> (Eigen::VectorXd const &amp;loc) const</td></tr>
<tr class="memdesc:a47da5b59500260002791434098105bfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the basis functions at a point.  <a href="classclf_1_1SupportPoint.html#a47da5b59500260002791434098105bfc">More...</a><br /></td></tr>
<tr class="separator:a47da5b59500260002791434098105bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1195050936b9ead1123358a7b992836"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1SupportPoint.html#af1195050936b9ead1123358a7b992836">EvaluateLocalFunction</a> (Eigen::VectorXd const &amp;loc) const</td></tr>
<tr class="memdesc:af1195050936b9ead1123358a7b992836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the local function associated with this support point using the stored coefficients.  <a href="classclf_1_1SupportPoint.html#af1195050936b9ead1123358a7b992836">More...</a><br /></td></tr>
<tr class="separator:af1195050936b9ead1123358a7b992836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cc9fa79f01afca65e512a33128ff8c7"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1SupportPoint.html#a9cc9fa79f01afca65e512a33128ff8c7">EvaluateLocalFunction</a> (Eigen::VectorXd const &amp;loc, Eigen::VectorXd const &amp;coeffs) const</td></tr>
<tr class="memdesc:a9cc9fa79f01afca65e512a33128ff8c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the local function associated with this support point with given coefficients.  <a href="classclf_1_1SupportPoint.html#a9cc9fa79f01afca65e512a33128ff8c7">More...</a><br /></td></tr>
<tr class="separator:a9cc9fa79f01afca65e512a33128ff8c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9366679d12d303a4b31eb3ac44349e2"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1SupportPoint.html#ab9366679d12d303a4b31eb3ac44349e2">EvaluateLocalFunction</a> (Eigen::VectorXd const &amp;coeffs, std::vector&lt; Eigen::VectorXd &gt; const &amp;basisEvals) const</td></tr>
<tr class="memdesc:ab9366679d12d303a4b31eb3ac44349e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the local function associated with this support point with given coefficients and previously evaluated basis functions.  <a href="classclf_1_1SupportPoint.html#ab9366679d12d303a4b31eb3ac44349e2">More...</a><br /></td></tr>
<tr class="separator:ab9366679d12d303a4b31eb3ac44349e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9bbf069c3a1236c5b4bd675e8d0afc0"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1SupportPoint.html#aa9bbf069c3a1236c5b4bd675e8d0afc0">GlobalNeighborIndex</a> (std::size_t const localInd) const</td></tr>
<tr class="memdesc:aa9bbf069c3a1236c5b4bd675e8d0afc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The global index of a neighbor given its local index.  <a href="classclf_1_1SupportPoint.html#aa9bbf069c3a1236c5b4bd675e8d0afc0">More...</a><br /></td></tr>
<tr class="separator:aa9bbf069c3a1236c5b4bd675e8d0afc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29508a1c59c7060f1a05f2bef72eca16"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1SupportPoint.html#a29508a1c59c7060f1a05f2bef72eca16">Coefficients</a> () const</td></tr>
<tr class="memdesc:a29508a1c59c7060f1a05f2bef72eca16"><td class="mdescLeft">&#160;</td><td class="mdescRight">The stored coefficients that define the local function.  <a href="classclf_1_1SupportPoint.html#a29508a1c59c7060f1a05f2bef72eca16">More...</a><br /></td></tr>
<tr class="separator:a29508a1c59c7060f1a05f2bef72eca16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01a82da9856094514e1a035a09913126"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1SupportPoint.html#a01a82da9856094514e1a035a09913126">Coefficients</a> ()</td></tr>
<tr class="memdesc:a01a82da9856094514e1a035a09913126"><td class="mdescLeft">&#160;</td><td class="mdescRight">The stored coefficients that define the local function.  <a href="classclf_1_1SupportPoint.html#a01a82da9856094514e1a035a09913126">More...</a><br /></td></tr>
<tr class="separator:a01a82da9856094514e1a035a09913126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ca4c48c8ead41c45d96278ac7f5527d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1SupportPoint.html#a6ca4c48c8ead41c45d96278ac7f5527d">ComputeUncoupledCost</a> () const</td></tr>
<tr class="memdesc:a6ca4c48c8ead41c45d96278ac7f5527d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the uncoupled cost using the stored coefficients.  <a href="classclf_1_1SupportPoint.html#a6ca4c48c8ead41c45d96278ac7f5527d">More...</a><br /></td></tr>
<tr class="separator:a6ca4c48c8ead41c45d96278ac7f5527d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa13f7dfeeae708f4b46d610b045c65d4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1SupportPoint.html#aa13f7dfeeae708f4b46d610b045c65d4">ComputeCoupledCost</a> () const</td></tr>
<tr class="memdesc:aa13f7dfeeae708f4b46d610b045c65d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the coupled cost using the stored coefficients.  <a href="classclf_1_1SupportPoint.html#aa13f7dfeeae708f4b46d610b045c65d4">More...</a><br /></td></tr>
<tr class="separator:aa13f7dfeeae708f4b46d610b045c65d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a5b8739537ae965130af63e854bb136"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1SupportPoint.html#a1a5b8739537ae965130af63e854bb136">CouplingFunction</a> (std::size_t const neighInd) const</td></tr>
<tr class="memdesc:a1a5b8739537ae965130af63e854bb136"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the coupling coefficient between this support point and its neighbor.  <a href="classclf_1_1SupportPoint.html#a1a5b8739537ae965130af63e854bb136">More...</a><br /></td></tr>
<tr class="separator:a1a5b8739537ae965130af63e854bb136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad18f76b6a32524e70fceeea26d2438d8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1SupportPoint.html#ad18f76b6a32524e70fceeea26d2438d8">SquaredDistanceToNeighbor</a> (std::size_t const i) const</td></tr>
<tr class="memdesc:ad18f76b6a32524e70fceeea26d2438d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the squared distance to the \(i^{th}\) neighbor.  <a href="classclf_1_1SupportPoint.html#ad18f76b6a32524e70fceeea26d2438d8">More...</a><br /></td></tr>
<tr class="separator:ad18f76b6a32524e70fceeea26d2438d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fac77ae1b155f02fa1aefcc496fdbf6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1SupportPoint.html#a9fac77ae1b155f02fa1aefcc496fdbf6">Coupled</a> () const</td></tr>
<tr class="memdesc:a9fac77ae1b155f02fa1aefcc496fdbf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this point coupled to its nearest neighbors?  <a href="classclf_1_1SupportPoint.html#a9fac77ae1b155f02fa1aefcc496fdbf6">More...</a><br /></td></tr>
<tr class="separator:a9fac77ae1b155f02fa1aefcc496fdbf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a7a0beccc9a388620af33d94e135801"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1SupportPoint.html#a0a7a0beccc9a388620af33d94e135801">ComputeOptimalCoefficients</a> (Eigen::MatrixXd const &amp;data)</td></tr>
<tr class="memdesc:a0a7a0beccc9a388620af33d94e135801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the optimal coefficients given data at this point's nearest neighbors.  <a href="classclf_1_1SupportPoint.html#a0a7a0beccc9a388620af33d94e135801">More...</a><br /></td></tr>
<tr class="separator:a0a7a0beccc9a388620af33d94e135801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classclf_1_1Point"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classclf_1_1Point')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classclf_1_1Point.html">clf::Point</a></td></tr>
<tr class="memitem:a9bcddcbc479841d5c4d99fd1e2da2262 inherit pub_methods_classclf_1_1Point"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1Point.html#a9bcddcbc479841d5c4d99fd1e2da2262">Point</a> (Eigen::VectorXd const &amp;<a class="el" href="classclf_1_1Point.html#a924a7c8615369f3eb912ac6d58ca3ddc">x</a>, std::shared_ptr&lt; const <a class="el" href="classclf_1_1Model.html">Model</a> &gt; const &amp;<a class="el" href="classclf_1_1Point.html#a2fb18cbc12df77c3ea9bc1eac66b50ed">model</a>)</td></tr>
<tr class="separator:a9bcddcbc479841d5c4d99fd1e2da2262 inherit pub_methods_classclf_1_1Point"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50f9339ef307fff6cb6e9e9dbd970652 inherit pub_methods_classclf_1_1Point"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1Point.html#a50f9339ef307fff6cb6e9e9dbd970652">~Point</a> ()=default</td></tr>
<tr class="separator:a50f9339ef307fff6cb6e9e9dbd970652 inherit pub_methods_classclf_1_1Point"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d39c222e6dea451759f5063f3f55aa1 inherit pub_methods_classclf_1_1Point"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1Point.html#a2d39c222e6dea451759f5063f3f55aa1">RightHandSide</a> () const</td></tr>
<tr class="memdesc:a2d39c222e6dea451759f5063f3f55aa1 inherit pub_methods_classclf_1_1Point"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the right hand side at this point's location.  <a href="classclf_1_1Point.html#a2d39c222e6dea451759f5063f3f55aa1">More...</a><br /></td></tr>
<tr class="separator:a2d39c222e6dea451759f5063f3f55aa1 inherit pub_methods_classclf_1_1Point"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb3695f14c4704d773a9eaa05d3d2bef inherit pub_methods_classclf_1_1Point"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1Point.html#adb3695f14c4704d773a9eaa05d3d2bef">RightHandSide</a> (Eigen::VectorXd const &amp;loc) const</td></tr>
<tr class="memdesc:adb3695f14c4704d773a9eaa05d3d2bef inherit pub_methods_classclf_1_1Point"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the right hand side at a given location.  <a href="classclf_1_1Point.html#adb3695f14c4704d773a9eaa05d3d2bef">More...</a><br /></td></tr>
<tr class="separator:adb3695f14c4704d773a9eaa05d3d2bef inherit pub_methods_classclf_1_1Point"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a408ad715de6b64c43d8933b763ba7eb2"><td class="memTemplParams" colspan="2">template&lt;typename PointType  = SupportPoint&gt; </td></tr>
<tr class="memitem:a408ad715de6b64c43d8933b763ba7eb2"><td class="memTemplItemLeft" align="right" valign="top">static std::shared_ptr&lt; PointType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classclf_1_1SupportPoint.html#a408ad715de6b64c43d8933b763ba7eb2">Construct</a> (Eigen::VectorXd const &amp;<a class="el" href="classclf_1_1Point.html#a924a7c8615369f3eb912ac6d58ca3ddc">x</a>, std::shared_ptr&lt; const <a class="el" href="classclf_1_1Model.html">Model</a> &gt; const &amp;<a class="el" href="classclf_1_1Point.html#a2fb18cbc12df77c3ea9bc1eac66b50ed">model</a>, boost::property_tree::ptree const &amp;pt)</td></tr>
<tr class="memdesc:a408ad715de6b64c43d8933b763ba7eb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A static construct method.  <a href="classclf_1_1SupportPoint.html#a408ad715de6b64c43d8933b763ba7eb2">More...</a><br /></td></tr>
<tr class="separator:a408ad715de6b64c43d8933b763ba7eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b6d5073198a90fcb7b35836b8641a65"><td class="memTemplParams" colspan="2">template&lt;typename PointType  = SupportPoint&gt; </td></tr>
<tr class="memitem:a0b6d5073198a90fcb7b35836b8641a65"><td class="memTemplItemLeft" align="right" valign="top">static std::shared_ptr&lt; PointType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classclf_1_1SupportPoint.html#a0b6d5073198a90fcb7b35836b8641a65">Construct</a> (Eigen::VectorXd const &amp;<a class="el" href="classclf_1_1Point.html#a924a7c8615369f3eb912ac6d58ca3ddc">x</a>, boost::property_tree::ptree const &amp;pt)</td></tr>
<tr class="memdesc:a0b6d5073198a90fcb7b35836b8641a65"><td class="mdescLeft">&#160;</td><td class="mdescRight">A static construct method using the identity model.  <a href="classclf_1_1SupportPoint.html#a0b6d5073198a90fcb7b35836b8641a65">More...</a><br /></td></tr>
<tr class="separator:a0b6d5073198a90fcb7b35836b8641a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:aa2d5cd73b17dd805fc43f2aed510dd4c"><td class="memItemLeft" align="right" valign="top">friend&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1SupportPoint.html#aa2d5cd73b17dd805fc43f2aed510dd4c">GlobalCost</a></td></tr>
<tr class="memdesc:aa2d5cd73b17dd805fc43f2aed510dd4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The global cost function is a friend.  <a href="classclf_1_1SupportPoint.html#aa2d5cd73b17dd805fc43f2aed510dd4c">More...</a><br /></td></tr>
<tr class="separator:aa2d5cd73b17dd805fc43f2aed510dd4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classclf_1_1Point"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classclf_1_1Point')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classclf_1_1Point.html">clf::Point</a></td></tr>
<tr class="memitem:a924a7c8615369f3eb912ac6d58ca3ddc inherit pub_attribs_classclf_1_1Point"><td class="memItemLeft" align="right" valign="top">const Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1Point.html#a924a7c8615369f3eb912ac6d58ca3ddc">x</a></td></tr>
<tr class="memdesc:a924a7c8615369f3eb912ac6d58ca3ddc inherit pub_attribs_classclf_1_1Point"><td class="mdescLeft">&#160;</td><td class="mdescRight">The location of the support point \(x\).  <a href="classclf_1_1Point.html#a924a7c8615369f3eb912ac6d58ca3ddc">More...</a><br /></td></tr>
<tr class="separator:a924a7c8615369f3eb912ac6d58ca3ddc inherit pub_attribs_classclf_1_1Point"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fb18cbc12df77c3ea9bc1eac66b50ed inherit pub_attribs_classclf_1_1Point"><td class="memItemLeft" align="right" valign="top">const std::shared_ptr&lt; const <a class="el" href="classclf_1_1Model.html">Model</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1Point.html#a2fb18cbc12df77c3ea9bc1eac66b50ed">model</a></td></tr>
<tr class="memdesc:a2fb18cbc12df77c3ea9bc1eac66b50ed inherit pub_attribs_classclf_1_1Point"><td class="mdescLeft">&#160;</td><td class="mdescRight">The model that defines the data/observations at this support point.  <a href="classclf_1_1Point.html#a2fb18cbc12df77c3ea9bc1eac66b50ed">More...</a><br /></td></tr>
<tr class="separator:a2fb18cbc12df77c3ea9bc1eac66b50ed inherit pub_attribs_classclf_1_1Point"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ac8fed824ab50f3ccdd064c42cfa1ff29"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1SupportPoint.html#ac8fed824ab50f3ccdd064c42cfa1ff29">SupportPoint</a> (Eigen::VectorXd const &amp;<a class="el" href="classclf_1_1Point.html#a924a7c8615369f3eb912ac6d58ca3ddc">x</a>, std::shared_ptr&lt; const <a class="el" href="classclf_1_1Model.html">Model</a> &gt; const &amp;<a class="el" href="classclf_1_1Point.html#a2fb18cbc12df77c3ea9bc1eac66b50ed">model</a>, boost::property_tree::ptree const &amp;pt)</td></tr>
<tr class="separator:ac8fed824ab50f3ccdd064c42cfa1ff29"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a3dd5171807e6b1e1b9e3cd08ba86c14f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1SupportPoint.html#a3dd5171807e6b1e1b9e3cd08ba86c14f">squaredNeighborDistances</a></td></tr>
<tr class="memdesc:a3dd5171807e6b1e1b9e3cd08ba86c14f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The squared distances (Euclidean inner product) between the support point and its \(j^{th}\) nearest neighbor.  <a href="classclf_1_1SupportPoint.html#a3dd5171807e6b1e1b9e3cd08ba86c14f">More...</a><br /></td></tr>
<tr class="separator:a3dd5171807e6b1e1b9e3cd08ba86c14f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a4401a43f7fc8d0abd9b53801e74aeaf5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1SupportPoint.html#a4401a43f7fc8d0abd9b53801e74aeaf5">ComputeNearestNeighborKernel</a> ()</td></tr>
<tr class="memdesc:a4401a43f7fc8d0abd9b53801e74aeaf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the nearest neighbor kernel at each neighboring support point.  <a href="classclf_1_1SupportPoint.html#a4401a43f7fc8d0abd9b53801e74aeaf5">More...</a><br /></td></tr>
<tr class="separator:a4401a43f7fc8d0abd9b53801e74aeaf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67c5051067f804050afb7ef5e2685cd1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1SupportPoint.html#a67c5051067f804050afb7ef5e2685cd1">ComputeLeastSquaresInformation</a> ()</td></tr>
<tr class="memdesc:a67c5051067f804050afb7ef5e2685cd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the information that allows us to solve the least squares problem.  <a href="classclf_1_1SupportPoint.html#a67c5051067f804050afb7ef5e2685cd1">More...</a><br /></td></tr>
<tr class="separator:a67c5051067f804050afb7ef5e2685cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:aa89e5c7d718cd45843afcea6f333ce73"><td class="memItemLeft" align="right" valign="top">static std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1SupportPoint.html#aa89e5c7d718cd45843afcea6f333ce73">DetermineNumNeighbors</a> (std::vector&lt; std::shared_ptr&lt; const <a class="el" href="classclf_1_1BasisFunctions.html">BasisFunctions</a> &gt; &gt; const &amp;<a class="el" href="classclf_1_1SupportPoint.html#aff92cdca79c6777f3507d155afcde8d2">bases</a>, boost::property_tree::ptree const &amp;pt)</td></tr>
<tr class="memdesc:aa89e5c7d718cd45843afcea6f333ce73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the number of nearest nieghbors for each output.  <a href="classclf_1_1SupportPoint.html#aa89e5c7d718cd45843afcea6f333ce73">More...</a><br /></td></tr>
<tr class="separator:aa89e5c7d718cd45843afcea6f333ce73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbef8984aa8821a5f799c96d31406059"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; std::shared_ptr&lt; const <a class="el" href="classclf_1_1BasisFunctions.html">BasisFunctions</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1SupportPoint.html#acbef8984aa8821a5f799c96d31406059">CreateBasisFunctions</a> (std::shared_ptr&lt; <a class="el" href="classclf_1_1SupportPoint.html">SupportPoint</a> &gt; const &amp;point, std::size_t const indim, std::size_t const outdim, boost::property_tree::ptree pt)</td></tr>
<tr class="memdesc:acbef8984aa8821a5f799c96d31406059"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the basis functions from the given options.  <a href="classclf_1_1SupportPoint.html#acbef8984aa8821a5f799c96d31406059">More...</a><br /></td></tr>
<tr class="separator:acbef8984aa8821a5f799c96d31406059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a374c370cb9b252a86b51dfa5b4d3fb32"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; const <a class="el" href="classclf_1_1BasisFunctions.html">BasisFunctions</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1SupportPoint.html#a374c370cb9b252a86b51dfa5b4d3fb32">CreateBasisFunctions</a> (std::shared_ptr&lt; <a class="el" href="classclf_1_1SupportPoint.html">SupportPoint</a> &gt; const &amp;point, std::size_t const indim, boost::property_tree::ptree pt)</td></tr>
<tr class="memdesc:a374c370cb9b252a86b51dfa5b4d3fb32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the basis functions from the given options.  <a href="classclf_1_1SupportPoint.html#a374c370cb9b252a86b51dfa5b4d3fb32">More...</a><br /></td></tr>
<tr class="separator:a374c370cb9b252a86b51dfa5b4d3fb32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0488c9a754738ff0d6fdf82ac6faa4c5"><td class="memItemLeft" align="right" valign="top">static std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1SupportPoint.html#a0488c9a754738ff0d6fdf82ac6faa4c5">ComputeNumCoefficients</a> (std::vector&lt; std::shared_ptr&lt; const <a class="el" href="classclf_1_1BasisFunctions.html">BasisFunctions</a> &gt; &gt; const &amp;<a class="el" href="classclf_1_1SupportPoint.html#aff92cdca79c6777f3507d155afcde8d2">bases</a>)</td></tr>
<tr class="memdesc:a0488c9a754738ff0d6fdf82ac6faa4c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of coefficients associated with this support point.  <a href="classclf_1_1SupportPoint.html#a0488c9a754738ff0d6fdf82ac6faa4c5">More...</a><br /></td></tr>
<tr class="separator:a0488c9a754738ff0d6fdf82ac6faa4c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a70dfb43c1eee3e018e5fe808279a96c6"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1SupportPoint.html#a70dfb43c1eee3e018e5fe808279a96c6">numCoefficients</a></td></tr>
<tr class="memdesc:a70dfb43c1eee3e018e5fe808279a96c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of coefficients associated with this support point.  <a href="classclf_1_1SupportPoint.html#a70dfb43c1eee3e018e5fe808279a96c6">More...</a><br /></td></tr>
<tr class="separator:a70dfb43c1eee3e018e5fe808279a96c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f57f3380cd7fef5ded3dfcab367943"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1SupportPoint.html#a37f57f3380cd7fef5ded3dfcab367943">nearestNeighborKernel</a></td></tr>
<tr class="memdesc:a37f57f3380cd7fef5ded3dfcab367943"><td class="mdescLeft">&#160;</td><td class="mdescRight">The nearest neighbor kernel at each neighboring support point.  <a href="classclf_1_1SupportPoint.html#a37f57f3380cd7fef5ded3dfcab367943">More...</a><br /></td></tr>
<tr class="separator:a37f57f3380cd7fef5ded3dfcab367943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff92cdca79c6777f3507d155afcde8d2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; const <a class="el" href="classclf_1_1BasisFunctions.html">BasisFunctions</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1SupportPoint.html#aff92cdca79c6777f3507d155afcde8d2">bases</a></td></tr>
<tr class="memdesc:aff92cdca79c6777f3507d155afcde8d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The bases that defines this support point.  <a href="classclf_1_1SupportPoint.html#aff92cdca79c6777f3507d155afcde8d2">More...</a><br /></td></tr>
<tr class="separator:aff92cdca79c6777f3507d155afcde8d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a618ea691247bf9207064ea2588dfe9"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1SupportPoint.html#a9a618ea691247bf9207064ea2588dfe9">numNeighbors</a></td></tr>
<tr class="memdesc:a9a618ea691247bf9207064ea2588dfe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of nearest neighbors used to compute the coefficients for each output.  <a href="classclf_1_1SupportPoint.html#a9a618ea691247bf9207064ea2588dfe9">More...</a><br /></td></tr>
<tr class="separator:a9a618ea691247bf9207064ea2588dfe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af51a10e9ce3c32948fa235293f050e7f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1SupportPoint.html#af51a10e9ce3c32948fa235293f050e7f">globalNeighorIndices</a></td></tr>
<tr class="memdesc:af51a10e9ce3c32948fa235293f050e7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The global indices (in a <a class="el" href="classclf_1_1SupportPointCloud.html" title="The cloud of support points  that defines the coupled local function.">clf::SupportPointCloud</a>) of the nearest neighbors.  <a href="classclf_1_1SupportPoint.html#af51a10e9ce3c32948fa235293f050e7f">More...</a><br /></td></tr>
<tr class="separator:af51a10e9ce3c32948fa235293f050e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d22a168e8ff518fac2cf5c98c42fb14"><td class="memItemLeft" align="right" valign="top">std::weak_ptr&lt; const <a class="el" href="classclf_1_1SupportPointCloud.html">SupportPointCloud</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1SupportPoint.html#a0d22a168e8ff518fac2cf5c98c42fb14">cloud</a></td></tr>
<tr class="memdesc:a0d22a168e8ff518fac2cf5c98c42fb14"><td class="mdescLeft">&#160;</td><td class="mdescRight">The cloud that stores this point and its nearest neighbor.  <a href="classclf_1_1SupportPoint.html#a0d22a168e8ff518fac2cf5c98c42fb14">More...</a><br /></td></tr>
<tr class="separator:a0d22a168e8ff518fac2cf5c98c42fb14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acac50f8bfdc89926dd6bf0aa41e0e177"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classclf_1_1UncoupledCost.html">UncoupledCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1SupportPoint.html#acac50f8bfdc89926dd6bf0aa41e0e177">uncoupledCost</a></td></tr>
<tr class="memdesc:acac50f8bfdc89926dd6bf0aa41e0e177"><td class="mdescLeft">&#160;</td><td class="mdescRight">The uncoupled cost function.  <a href="classclf_1_1SupportPoint.html#acac50f8bfdc89926dd6bf0aa41e0e177">More...</a><br /></td></tr>
<tr class="separator:acac50f8bfdc89926dd6bf0aa41e0e177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad23f96e9e73e8c47feaf8c74cb03e46f"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="namespaceclf.html#aecbe390df227db79bde7b77d71dc1dac">DenseQuadraticCostOptimizer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1SupportPoint.html#ad23f96e9e73e8c47feaf8c74cb03e46f">quadOptimizer</a> = nullptr</td></tr>
<tr class="memdesc:ad23f96e9e73e8c47feaf8c74cb03e46f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this optimizer to minimize the uncoupled cost.  <a href="classclf_1_1SupportPoint.html#ad23f96e9e73e8c47feaf8c74cb03e46f">More...</a><br /></td></tr>
<tr class="separator:ad23f96e9e73e8c47feaf8c74cb03e46f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72c372c3038dd0350fd3ebd351907b33"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classclf_1_1CoupledCost.html">CoupledCost</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1SupportPoint.html#a72c372c3038dd0350fd3ebd351907b33">coupledCost</a></td></tr>
<tr class="memdesc:a72c372c3038dd0350fd3ebd351907b33"><td class="mdescLeft">&#160;</td><td class="mdescRight">The coupling cost function, if this point is coupled with its nearest neighbors.  <a href="classclf_1_1SupportPoint.html#a72c372c3038dd0350fd3ebd351907b33">More...</a><br /></td></tr>
<tr class="separator:a72c372c3038dd0350fd3ebd351907b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acafae79b49e95205ba32b38c8b66faa5"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1SupportPoint.html#acafae79b49e95205ba32b38c8b66faa5">coefficients</a></td></tr>
<tr class="memdesc:acafae79b49e95205ba32b38c8b66faa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The coefficients used to evaluate the local function associated with this support point.  <a href="classclf_1_1SupportPoint.html#acafae79b49e95205ba32b38c8b66faa5">More...</a><br /></td></tr>
<tr class="separator:acafae79b49e95205ba32b38c8b66faa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784f00e7d883c3982c5a3420a78a28a0"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1SupportPoint.html#a784f00e7d883c3982c5a3420a78a28a0">lsJacobian</a></td></tr>
<tr class="memdesc:a784f00e7d883c3982c5a3420a78a28a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The least squares Jacobian matrix.  <a href="classclf_1_1SupportPoint.html#a784f00e7d883c3982c5a3420a78a28a0">More...</a><br /></td></tr>
<tr class="separator:a784f00e7d883c3982c5a3420a78a28a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The local function \(\ell_{\hat{x}}\) associated with a support point \(\hat{x}\). </p>
<p>Let \(\hat{x} \in \Omega\) be a support point with an associated local function \(\ell: \Omega \mapsto \mathbb{R}^{m}\). Suppose that we are building an approximation of the function \(u:\Omega \mapsto \mathbb{R}^{m}\).</p>
<p>The basis functions for the \(j^{th}\) output are </p><p class="formulaDsp">
\begin{equation*} \phi_{\hat{x}}^{(j)}(x) = [\phi_1(x),\, \phi_2(x),\, ...,\, \phi_{q_j}(x)]^{\top}. \end{equation*}
</p>
<p> The \(j^{th}\) output of the local function is defined by coefficients \(p_j \in \mathbb{R}^{q_j}\) such that \(\ell_{\hat{x}}^{(j)}(x) = \phi_j(x)^{\top} p\). Let \(\tilde{q} = \sum_{j=1}^{m} q_j\) be the total number of coefficients. Define the \(m \times \tilde{q}\) matrix </p><p class="formulaDsp">
\begin{equation*} \Phi_{\hat{x}}(x) = \left[ \begin{array}{ccc|ccc|c|ccc} --- &amp; (\boldsymbol{\phi}_{\hat{x}}^{(0)}(x))^{\top} &amp; --- &amp; --- &amp; 0 &amp; --- &amp; ... &amp; --- &amp; 0 &amp; --- \\ --- &amp; 0 &amp; --- &amp; --- &amp; (\boldsymbol{\phi}_{\hat{x}}^{(1)}(x))^{\top} &amp; --- &amp; ... &amp; --- &amp; 0 &amp; --- \\ --- &amp; \vdots &amp; --- &amp; --- &amp; \vdots &amp; --- &amp; \ddots &amp; --- &amp; \vdots &amp; --- \\ --- &amp; 0 &amp; --- &amp; --- &amp; 0 &amp; --- &amp; ... &amp; --- &amp; (\boldsymbol{\phi}_{\hat{x}}^{(m)}(x))^{\top} &amp; --- \end{array} \right] \end{equation*}
</p>
<p> such that \(\ell_{\hat{x}}(x) = \Phi_{\hat{x}}(x) p\), where \(p \in \mathbb{R}^{\tilde{q}}\) are the coefficients that define the local function.</p>
<p><b>Configuration Parameters:</b> </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Parameter Key </th><th class="markdownTableHeadNone">Type </th><th class="markdownTableHeadNone">Default Value </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">"BasisFunctions" </td><td class="markdownTableBodyNone"><code>std::string</code> </td><td class="markdownTableBodyNone">&mdash; </td><td class="markdownTableBodyNone">The options to make the basis functions for each output, separated by commas (see <a class="el" href="classclf_1_1SupportPoint.html#acbef8984aa8821a5f799c96d31406059" title="Create the basis functions from the given options.">SupportPoint::CreateBasisFunctions</a>)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">"NumNeighbors" </td><td class="markdownTableBodyNone"><code>std::size_t</code> </td><td class="markdownTableBodyNone">The number of basis functions plus one </td><td class="markdownTableBodyNone">The number of nearest neighbors to use to compute the coefficients for each output.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">"Optimization" </td><td class="markdownTableBodyNone"><code>boost::property_tree::ptree</code> </td><td class="markdownTableBodyNone">see clf::OptimizationOptions </td><td class="markdownTableBodyNone">The options for the uncoupled cost minimization  </td></tr>
</table>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac8fed824ab50f3ccdd064c42cfa1ff29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8fed824ab50f3ccdd064c42cfa1ff29">&#9670;&nbsp;</a></span>SupportPoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SupportPoint::SupportPoint </td>
          <td>(</td>
          <td class="paramtype">Eigen::VectorXd const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classclf_1_1Model.html">Model</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::property_tree::ptree const &amp;&#160;</td>
          <td class="paramname"><em>pt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The location of the support point \(x\) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model</td><td>The model that defines the "data" at this support point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pt</td><td>The options for the support point </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb659eeca56a870923457dcf7303c62d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb659eeca56a870923457dcf7303c62d">&#9670;&nbsp;</a></span>~SupportPoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual clf::SupportPoint::~SupportPoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a01a82da9856094514e1a035a09913126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01a82da9856094514e1a035a09913126">&#9670;&nbsp;</a></span>Coefficients() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd&amp; clf::SupportPoint::Coefficients </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The stored coefficients that define the local function. </p>
<dl class="section return"><dt>Returns</dt><dd>The stored coefficients that define the local function </dd></dl>

</div>
</div>
<a id="a29508a1c59c7060f1a05f2bef72eca16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29508a1c59c7060f1a05f2bef72eca16">&#9670;&nbsp;</a></span>Coefficients() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd &amp; SupportPoint::Coefficients </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The stored coefficients that define the local function. </p>
<dl class="section return"><dt>Returns</dt><dd>The stored coefficients that define the local function </dd></dl>

</div>
</div>
<a id="aa13f7dfeeae708f4b46d610b045c65d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa13f7dfeeae708f4b46d610b045c65d4">&#9670;&nbsp;</a></span>ComputeCoupledCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SupportPoint::ComputeCoupledCost </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the coupled cost using the stored coefficients. </p>
<p>The coupled cost is the sum of the coupled cost with each point&mdash;returns zero if this point is not coupled with its nearest neighbors. </p><dl class="section return"><dt>Returns</dt><dd>The coupled cost given the stored coefficients </dd></dl>

</div>
</div>
<a id="a67c5051067f804050afb7ef5e2685cd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67c5051067f804050afb7ef5e2685cd1">&#9670;&nbsp;</a></span>ComputeLeastSquaresInformation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SupportPoint::ComputeLeastSquaresInformation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the information that allows us to solve the least squares problem. </p>
<p>The least squares problem is </p><p class="formulaDsp">
\begin{equation*} \min_{p \in \mathbb{R}^{n}}{ ( \| V p - \bar{u} \|_{K} ) }, \end{equation*}
</p>
<p> where \(V\) is the Vandermonde matrix and \(K\) is the diagonal kernel matrix. The solution is </p><p class="formulaDsp">
\begin{equation*} p = (V^{\top} K V)^{-1} V^{\top} K \bar{u}. \end{equation*}
</p>
<p> This functions computes the matrix of \((V^{\top} K V^{-1} V^{\top} K\) using the Cholesky decomposition. </p>

</div>
</div>
<a id="a4401a43f7fc8d0abd9b53801e74aeaf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4401a43f7fc8d0abd9b53801e74aeaf5">&#9670;&nbsp;</a></span>ComputeNearestNeighborKernel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SupportPoint::ComputeNearestNeighborKernel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluate the nearest neighbor kernel at each neighboring support point. </p>
<p>Stores the evaluations in <a class="el" href="classclf_1_1SupportPoint.html#a37f57f3380cd7fef5ded3dfcab367943" title="The nearest neighbor kernel at each neighboring support point.">SupportPoint::nearestNeighborKernel</a>. </p>

</div>
</div>
<a id="a0488c9a754738ff0d6fdf82ac6faa4c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0488c9a754738ff0d6fdf82ac6faa4c5">&#9670;&nbsp;</a></span>ComputeNumCoefficients()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t SupportPoint::ComputeNumCoefficients </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::shared_ptr&lt; const <a class="el" href="classclf_1_1BasisFunctions.html">BasisFunctions</a> &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>bases</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of coefficients associated with this support point. </p>
<p>The total number of coefficients is the sum of the coefficients associated with each basis. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bases</td><td>The bases functions for each output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of coefficients associated with this support point </dd></dl>

</div>
</div>
<a id="a0a7a0beccc9a388620af33d94e135801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a7a0beccc9a388620af33d94e135801">&#9670;&nbsp;</a></span>ComputeOptimalCoefficients()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SupportPoint::ComputeOptimalCoefficients </td>
          <td>(</td>
          <td class="paramtype">Eigen::MatrixXd const &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the optimal coefficients given data at this point's nearest neighbors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The data at each of the nearest neighbors. Each column is the function we are tryng to approximate evaluated at the support point </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6ca4c48c8ead41c45d96278ac7f5527d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ca4c48c8ead41c45d96278ac7f5527d">&#9670;&nbsp;</a></span>ComputeUncoupledCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SupportPoint::ComputeUncoupledCost </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the uncoupled cost using the stored coefficients. </p>
<dl class="section return"><dt>Returns</dt><dd>The uncoupled cost given the stored coefficients </dd></dl>

</div>
</div>
<a id="a0b6d5073198a90fcb7b35836b8641a65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b6d5073198a90fcb7b35836b8641a65">&#9670;&nbsp;</a></span>Construct() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointType  = SupportPoint&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;PointType&gt; clf::SupportPoint::Construct </td>
          <td>(</td>
          <td class="paramtype">Eigen::VectorXd const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::property_tree::ptree const &amp;&#160;</td>
          <td class="paramname"><em>pt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A static construct method using the identity model. </p>
<p>Additionally requires the following parameters: <b>Configuration Parameters:</b> </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Parameter Key </th><th class="markdownTableHeadNone">Type </th><th class="markdownTableHeadNone">Default Value </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">"InputDimension" </td><td class="markdownTableBodyNone"><code>std::size_t</code> </td><td class="markdownTableBodyNone">&mdash; </td><td class="markdownTableBodyNone">The input dimension.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">"OutputDimension" </td><td class="markdownTableBodyNone"><code>std::size_t</code> </td><td class="markdownTableBodyNone">&mdash; </td><td class="markdownTableBodyNone">The output dimension.  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The location of the support point \(x\) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pt</td><td>The options for the support point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A smart pointer to the support point </dd></dl>

</div>
</div>
<a id="a408ad715de6b64c43d8933b763ba7eb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a408ad715de6b64c43d8933b763ba7eb2">&#9670;&nbsp;</a></span>Construct() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PointType  = SupportPoint&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;PointType&gt; clf::SupportPoint::Construct </td>
          <td>(</td>
          <td class="paramtype">Eigen::VectorXd const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classclf_1_1Model.html">Model</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::property_tree::ptree const &amp;&#160;</td>
          <td class="paramname"><em>pt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A static construct method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The location of the support point \(x\) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model</td><td>The model that defines the "data" at this support point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pt</td><td>The options for the support point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A smart pointer to the support point </dd></dl>

</div>
</div>
<a id="a9fac77ae1b155f02fa1aefcc496fdbf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fac77ae1b155f02fa1aefcc496fdbf6">&#9670;&nbsp;</a></span>Coupled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SupportPoint::Coupled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is this point coupled to its nearest neighbors? </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code>: This point is coupled to its nearest neighbors; <code>false</code>: This point is not coupled with its nearest neighbors </dd></dl>

</div>
</div>
<a id="a1a5b8739537ae965130af63e854bb136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a5b8739537ae965130af63e854bb136">&#9670;&nbsp;</a></span>CouplingFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SupportPoint::CouplingFunction </td>
          <td>(</td>
          <td class="paramtype">std::size_t const&#160;</td>
          <td class="paramname"><em>neighInd</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the coupling coefficient between this support point and its neighbor. </p>
<p>Defaults to returning zero, which means the support points are uncoupled </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">neighInd</td><td>The local index of the nearest neighbor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The coupling coefficient between this support point and its neighbor </dd></dl>

<p>Reimplemented in <a class="el" href="classclf_1_1CoupledSupportPoint.html#ac7294a95970e6639ab4a8bcb5ee9cbe2">clf::CoupledSupportPoint</a>.</p>

</div>
</div>
<a id="a374c370cb9b252a86b51dfa5b4d3fb32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a374c370cb9b252a86b51dfa5b4d3fb32">&#9670;&nbsp;</a></span>CreateBasisFunctions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;const <a class="el" href="classclf_1_1BasisFunctions.html">BasisFunctions</a>&gt; clf::SupportPoint::CreateBasisFunctions </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classclf_1_1SupportPoint.html">SupportPoint</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t const&#160;</td>
          <td class="paramname"><em>indim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::property_tree::ptree&#160;</td>
          <td class="paramname"><em>pt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create the basis functions from the given options. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">indim</td><td>The input dimension for the support point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pt</td><td>The options for the basis functions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The basis created given the options </dd></dl>

</div>
</div>
<a id="acbef8984aa8821a5f799c96d31406059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbef8984aa8821a5f799c96d31406059">&#9670;&nbsp;</a></span>CreateBasisFunctions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt;std::shared_ptr&lt;const <a class="el" href="classclf_1_1BasisFunctions.html">BasisFunctions</a>&gt; &gt; clf::SupportPoint::CreateBasisFunctions </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classclf_1_1SupportPoint.html">SupportPoint</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t const&#160;</td>
          <td class="paramname"><em>indim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t const&#160;</td>
          <td class="paramname"><em>outdim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::property_tree::ptree&#160;</td>
          <td class="paramname"><em>pt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create the basis functions from the given options. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">center</td><td>The point that defines the center of the local function ball \(\mathcal{B}_{\delta}(y)\) (the parameter \(y\)) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indim</td><td>The input dimension for the support point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outdim</td><td>The output dimension for the support point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pt</td><td>The options for the basis functions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bases used for each output </dd></dl>

</div>
</div>
<a id="a1ca855c8d98dcdec45759ebdb81d1d5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ca855c8d98dcdec45759ebdb81d1d5b">&#9670;&nbsp;</a></span>CreateCoupledCosts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SupportPoint::CreateCoupledCosts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the coupled cost functions. </p>
<p>Must be called after the nearest neighbors have been set for <em>all</em> of the support points. </p>

</div>
</div>
<a id="aa89e5c7d718cd45843afcea6f333ce73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa89e5c7d718cd45843afcea6f333ce73">&#9670;&nbsp;</a></span>DetermineNumNeighbors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t SupportPoint::DetermineNumNeighbors </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::shared_ptr&lt; const <a class="el" href="classclf_1_1BasisFunctions.html">BasisFunctions</a> &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>bases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::property_tree::ptree const &amp;&#160;</td>
          <td class="paramname"><em>pt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine the number of nearest nieghbors for each output. </p>
<p><b>Additional Configuration Parameters:</b> </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Parameter Key </th><th class="markdownTableHeadNone">Type </th><th class="markdownTableHeadNone">Default Value </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">"LocalBasis" </td><td class="markdownTableBodyNone"><code>bool</code> </td><td class="markdownTableBodyNone"><code>true</code> </td><td class="markdownTableBodyNone">Should we rescale the basis into local coordinates around the support point?  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bases</td><td>The bases used for each output </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pt</td><td>The options for the support point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of nearest neighbors used to compute the coefficients </dd></dl>

</div>
</div>
<a id="a47da5b59500260002791434098105bfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47da5b59500260002791434098105bfc">&#9670;&nbsp;</a></span>EvaluateBasisFunctions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Eigen::VectorXd &gt; SupportPoint::EvaluateBasisFunctions </td>
          <td>(</td>
          <td class="paramtype">Eigen::VectorXd const &amp;&#160;</td>
          <td class="paramname"><em>loc</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the basis functions at a point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">loc</td><td>The point where we want evaluate the basis function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Each component are the basis function evaluations for the corresponding output </dd></dl>

</div>
</div>
<a id="ab9366679d12d303a4b31eb3ac44349e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9366679d12d303a4b31eb3ac44349e2">&#9670;&nbsp;</a></span>EvaluateLocalFunction() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd SupportPoint::EvaluateLocalFunction </td>
          <td>(</td>
          <td class="paramtype">Eigen::VectorXd const &amp;&#160;</td>
          <td class="paramname"><em>coeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Eigen::VectorXd &gt; const &amp;&#160;</td>
          <td class="paramname"><em>basisEvals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the local function associated with this support point with given coefficients and previously evaluated basis functions. </p>
<p>Since we often have to repeatedly evaluate the local function at the same point with different coefficients, this allows us to precompute the basis evaluations. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">coeffs</td><td>The coefficients of the basis functions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">basisEvals</td><td>The basis functions evaluated for each output at the location loc </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function evaluation </dd></dl>

</div>
</div>
<a id="af1195050936b9ead1123358a7b992836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1195050936b9ead1123358a7b992836">&#9670;&nbsp;</a></span>EvaluateLocalFunction() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd SupportPoint::EvaluateLocalFunction </td>
          <td>(</td>
          <td class="paramtype">Eigen::VectorXd const &amp;&#160;</td>
          <td class="paramname"><em>loc</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the local function associated with this support point using the stored coefficients. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">loc</td><td>The point where we want to evaluate the local function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function evaluation </dd></dl>

</div>
</div>
<a id="a9cc9fa79f01afca65e512a33128ff8c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cc9fa79f01afca65e512a33128ff8c7">&#9670;&nbsp;</a></span>EvaluateLocalFunction() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd SupportPoint::EvaluateLocalFunction </td>
          <td>(</td>
          <td class="paramtype">Eigen::VectorXd const &amp;&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd const &amp;&#160;</td>
          <td class="paramname"><em>coeffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the local function associated with this support point with given coefficients. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">loc</td><td>The point where we want to evaluate the local function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coeffs</td><td>The coefficients of the basis functions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function evaluation </dd></dl>

</div>
</div>
<a id="aa8310de0c4f8aac473d8c4b6fbd996cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8310de0c4f8aac473d8c4b6fbd996cb">&#9670;&nbsp;</a></span>GetBasisFunctions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; std::shared_ptr&lt; const <a class="el" href="classclf_1_1BasisFunctions.html">BasisFunctions</a> &gt; &gt; &amp; SupportPoint::GetBasisFunctions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the basis function. </p>
<dl class="section return"><dt>Returns</dt><dd>Each component is the basis for the corresponding output </dd></dl>

</div>
</div>
<a id="aab7875c1409ca60d34b64f5516a4c8a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab7875c1409ca60d34b64f5516a4c8a0">&#9670;&nbsp;</a></span>GlobalIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t SupportPoint::GlobalIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the global index of this support point. </p>
<p>Return the maximum possible integer to indicate an invalid index. </p><dl class="section return"><dt>Returns</dt><dd>The global index of this support point </dd></dl>

</div>
</div>
<a id="aa9bbf069c3a1236c5b4bd675e8d0afc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9bbf069c3a1236c5b4bd675e8d0afc0">&#9670;&nbsp;</a></span>GlobalNeighborIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t SupportPoint::GlobalNeighborIndex </td>
          <td>(</td>
          <td class="paramtype">std::size_t const&#160;</td>
          <td class="paramname"><em>localInd</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The global index of a neighbor given its local index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">localInd</td><td>The local neighbor index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The global neighbor index </dd></dl>

</div>
</div>
<a id="a206938b979c66f0d8a8c76f661bd5824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a206938b979c66f0d8a8c76f661bd5824">&#9670;&nbsp;</a></span>GlobalNeighborIndices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::size_t &gt; const  &amp; SupportPoint::GlobalNeighborIndices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the global indices of this support points nearest neighbors. </p>
<dl class="section return"><dt>Returns</dt><dd>The global indices of this support points nearest neighbors </dd></dl>

</div>
</div>
<a id="a5e6957194b6ad852c3c5d1674b56b5e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e6957194b6ad852c3c5d1674b56b5e4">&#9670;&nbsp;</a></span>IsNeighbor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SupportPoint::IsNeighbor </td>
          <td>(</td>
          <td class="paramtype">std::size_t const &amp;&#160;</td>
          <td class="paramname"><em>globalInd</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a point (indexed by a global ID) is a nearest neighbor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">globalInd</td><td>The global index of a support point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code>: It is a nearest neighbor, <code>false</code>: It is not a nearest neighbor </dd></dl>

</div>
</div>
<a id="aee09ce5052201f542fe0b9477fa85254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee09ce5052201f542fe0b9477fa85254">&#9670;&nbsp;</a></span>LocalIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t SupportPoint::LocalIndex </td>
          <td>(</td>
          <td class="paramtype">std::size_t const&#160;</td>
          <td class="paramname"><em>globalInd</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the local index given the global index. </p>
<p>If the global index corresponds to one of the nearest neighbors, return the local index (this is the \(j^{th}\) nearest neighbor). If the global index does <em>not</em> correspond to a nearest neighbor, return the maximum possible integer to indicate an invalid index. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">globalInd</td><td>The global index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The local index (if the global index corresponds to a nearest neighbor) </dd></dl>

</div>
</div>
<a id="a1980764818adc66f28bfbbe91721b184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1980764818adc66f28bfbbe91721b184">&#9670;&nbsp;</a></span>MinimizeUncoupledCost() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double clf::SupportPoint::MinimizeUncoupledCost </td>
          <td>(</td>
          <td class="paramtype">boost::property_tree::ptree const &amp;&#160;</td>
          <td class="paramname"><em>options</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimize the uncoupled cost function (see <a class="el" href="classclf_1_1UncoupledCost.html" title="Compute the uncoupled cost associated with the support point at .">clf::UncoupledCost</a>) for this support point. </p>
<p>This minimization requires the <a class="el" href="classclf_1_1Point.html#a2fb18cbc12df77c3ea9bc1eac66b50ed" title="The model that defines the data/observations at this support point.">clf::Point::model</a> to have implemented the forcing function <a class="el" href="classclf_1_1Model.html#a61d3bb52525f563a42408c12012b28a9" title="Implement the right hand side function .">clf::Model::RightHandSide</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Options for the optimization algorithm </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The uncoupled cost at the optimal coefficients value </dd></dl>

</div>
</div>
<a id="af66449cf9a9cb3c866f0349253cd1546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af66449cf9a9cb3c866f0349253cd1546">&#9670;&nbsp;</a></span>MinimizeUncoupledCost() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double clf::SupportPoint::MinimizeUncoupledCost </td>
          <td>(</td>
          <td class="paramtype">Eigen::MatrixXd const &amp;&#160;</td>
          <td class="paramname"><em>forcing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::property_tree::ptree const &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimize the uncoupled cost function (see <a class="el" href="classclf_1_1UncoupledCost.html" title="Compute the uncoupled cost associated with the support point at .">clf::UncoupledCost</a>) for this support point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">forcing</td><td>The \(i^{th}\) column is the forcing function evaluated at the \(i^{th}\) support point \(f(x_i)\) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Options for the optimization algorithm </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The uncoupled cost at the optimal coefficients value </dd></dl>

</div>
</div>
<a id="ae45ffa377b72628b8cf92fb1e5add6e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae45ffa377b72628b8cf92fb1e5add6e6">&#9670;&nbsp;</a></span>NearestNeighbor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classclf_1_1SupportPoint.html">SupportPoint</a> &gt; SupportPoint::NearestNeighbor </td>
          <td>(</td>
          <td class="paramtype">std::size_t const&#160;</td>
          <td class="paramname"><em>jnd</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The support point associated with the \(j^{th}\) nearest neighbor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">jnd</td><td>The local index of the \(j^{th}\) nearest neighbor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The point associated with \(I(i,j)\) </dd></dl>

</div>
</div>
<a id="aea8bbccebd2f1c88e7c5baabaf4842a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea8bbccebd2f1c88e7c5baabaf4842a1">&#9670;&nbsp;</a></span>NearestNeighborKernel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd SupportPoint::NearestNeighborKernel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The nearest neighbor kernel at each neighboring support point. </p>
<dl class="section return"><dt>Returns</dt><dd>The kernel evaluation at each support point </dd></dl>

</div>
</div>
<a id="a6b7fc5c3c2e034c6f52790fd56469f33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b7fc5c3c2e034c6f52790fd56469f33">&#9670;&nbsp;</a></span>NearestNeighborKernel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SupportPoint::NearestNeighborKernel </td>
          <td>(</td>
          <td class="paramtype">std::size_t const&#160;</td>
          <td class="paramname"><em>ind</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The nearest neighbor kernel at the \(j^{th}\) closest support point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ind</td><td>The local index of the neighboring support point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The kernel evaluation at between this support point and its \(j^{th}\) closest neighbor </dd></dl>

</div>
</div>
<a id="afe0c7915a3b57b77012917b3ef962be6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe0c7915a3b57b77012917b3ef962be6">&#9670;&nbsp;</a></span>NumCoefficients()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t SupportPoint::NumCoefficients </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of coefficients associated with this support point. </p>
<p>The total number of coefficients is the sum of the coefficients associated with each basis. </p><dl class="section return"><dt>Returns</dt><dd>The number of coefficients associated with this support point </dd></dl>

</div>
</div>
<a id="a49afd98d9fbee487188b40fa818d84cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49afd98d9fbee487188b40fa818d84cb">&#9670;&nbsp;</a></span>NumNeighbors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t SupportPoint::NumNeighbors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of nearest neighbors. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of nearest neighbors </dd></dl>

</div>
</div>
<a id="afd19083fb31ceeb7ddd76c918d49c64e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd19083fb31ceeb7ddd76c918d49c64e">&#9670;&nbsp;</a></span>Operator() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd SupportPoint::Operator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluate the operator applied to the local function at the support point location. </p>

<p>Implements <a class="el" href="classclf_1_1Point.html#a986c9fbbe7003aea9bb8275684de1729">clf::Point</a>.</p>

</div>
</div>
<a id="aa5137423307ce0f7bcb33b3f4732c978"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5137423307ce0f7bcb33b3f4732c978">&#9670;&nbsp;</a></span>Operator() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd SupportPoint::Operator </td>
          <td>(</td>
          <td class="paramtype">Eigen::VectorXd const &amp;&#160;</td>
          <td class="paramname"><em>loc</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluate the operator applied to the local function at a given point using the stored coefficients. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">loc</td><td>The location where we are evaluating the action of the operator </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classclf_1_1Point.html#a1ff8e3f0bd20744eefa1840e79675176">clf::Point</a>.</p>

</div>
</div>
<a id="a27b9d412c1e2de492eca147aea8b2a1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27b9d412c1e2de492eca147aea8b2a1e">&#9670;&nbsp;</a></span>Operator() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd SupportPoint::Operator </td>
          <td>(</td>
          <td class="paramtype">Eigen::VectorXd const &amp;&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd const &amp;&#160;</td>
          <td class="paramname"><em>coeffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluate the operator applied to the local function at a given point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">loc</td><td>The location where we are evaluating the action of the operator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coeffs</td><td>The coefficients that define the local function </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classclf_1_1Point.html#ab9b59b8fd00847c01b77affdfd4cabe7">clf::Point</a>.</p>

</div>
</div>
<a id="a891889c998d507d6feea605889dd8f60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a891889c998d507d6feea605889dd8f60">&#9670;&nbsp;</a></span>OperatorHessian() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Eigen::MatrixXd &gt; SupportPoint::OperatorHessian </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluate the Hessian of the operator applied to the local function at a given point. </p>
<dl class="section return"><dt>Returns</dt><dd>Each component is the Hessian of the \(j^{th}\) ouput with respect to the coefficeints </dd></dl>

<p>Implements <a class="el" href="classclf_1_1Point.html#a7a64b3fb39bb4b3abafcee15098b4f9d">clf::Point</a>.</p>

</div>
</div>
<a id="a7d0f583841d7489ce58e6b7161b51d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d0f583841d7489ce58e6b7161b51d55">&#9670;&nbsp;</a></span>OperatorHessian() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Eigen::MatrixXd &gt; SupportPoint::OperatorHessian </td>
          <td>(</td>
          <td class="paramtype">Eigen::VectorXd const &amp;&#160;</td>
          <td class="paramname"><em>loc</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluate the Hessian of the operator applied to the local function at a given point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">loc</td><td>The location where we are evaluating the action of the operator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Each component is the Hessian of the \(j^{th}\) ouput with respect to the coefficeints </dd></dl>

<p>Implements <a class="el" href="classclf_1_1Point.html#ae6d181e285a80ed326f54d936290f777">clf::Point</a>.</p>

</div>
</div>
<a id="ac16ebf6587080a69b3c13c1d23442dde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac16ebf6587080a69b3c13c1d23442dde">&#9670;&nbsp;</a></span>OperatorHessian() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Eigen::MatrixXd &gt; SupportPoint::OperatorHessian </td>
          <td>(</td>
          <td class="paramtype">Eigen::VectorXd const &amp;&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd const &amp;&#160;</td>
          <td class="paramname"><em>coefficients</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluate the Hessian of the operator applied to the local function at a given point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">loc</td><td>The location where we are evaluating the action of the operator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coefficients</td><td>The coefficients that define the local function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Each component is the Hessian of the \(j^{th}\) ouput with respect to the coefficeints </dd></dl>

<p>Implements <a class="el" href="classclf_1_1Point.html#a6b281dad4f2a570aac7f4ec41589ee8d">clf::Point</a>.</p>

</div>
</div>
<a id="a605d391f300a254bee2b79eca49edefc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a605d391f300a254bee2b79eca49edefc">&#9670;&nbsp;</a></span>OperatorJacobian() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd SupportPoint::OperatorJacobian </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluate the Jacobian of the operator applied to the local function at the point's location with the stored coefficients. </p>
<dl class="section return"><dt>Returns</dt><dd>The model Jacobian with respect to the coefficeints </dd></dl>

<p>Implements <a class="el" href="classclf_1_1Point.html#ab477370714693398a296410592688033">clf::Point</a>.</p>

</div>
</div>
<a id="a4b3943dd78015f0e28b85cbee4e1353f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b3943dd78015f0e28b85cbee4e1353f">&#9670;&nbsp;</a></span>OperatorJacobian() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd SupportPoint::OperatorJacobian </td>
          <td>(</td>
          <td class="paramtype">Eigen::VectorXd const &amp;&#160;</td>
          <td class="paramname"><em>loc</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluate the Jacobian of the operator applied to the local function at a given point with the stored coefficients. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">loc</td><td>The location where we are evaluating the action of the operator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The model Jacobian with respect to the coefficeints </dd></dl>

<p>Implements <a class="el" href="classclf_1_1Point.html#afcb1ce23836324d13d1d655ae23ff563">clf::Point</a>.</p>

</div>
</div>
<a id="ae4ca8c2bc8cc6fc28dc60b10d560bb31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4ca8c2bc8cc6fc28dc60b10d560bb31">&#9670;&nbsp;</a></span>OperatorJacobian() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd SupportPoint::OperatorJacobian </td>
          <td>(</td>
          <td class="paramtype">Eigen::VectorXd const &amp;&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd const &amp;&#160;</td>
          <td class="paramname"><em>coeffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluate the Jacobian of the operator applied to the local function at a given point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">loc</td><td>The location where we are evaluating the action of the operator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coeffs</td><td>The coefficients that define the local function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The model Jacobian with respect to the coefficeints </dd></dl>

<p>Implements <a class="el" href="classclf_1_1Point.html#aab1e889c3701a165eab6f97be0cd0307">clf::Point</a>.</p>

</div>
</div>
<a id="ae8a95d7f165808dbea4d7e6dcf37cdea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8a95d7f165808dbea4d7e6dcf37cdea">&#9670;&nbsp;</a></span>SetNearestNeighbors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SupportPoint::SetNearestNeighbors </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classclf_1_1SupportPointCloud.html">SupportPointCloud</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>newcloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>neighInd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>neighDist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the nearest neighbors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">newcloud</td><td>The <a class="el" href="classclf_1_1SupportPointCloud.html" title="The cloud of support points  that defines the coupled local function.">clf::SupportPointCloud</a> where this support point and its neighbors are stored </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">neighInd</td><td>The global indices (in a <a class="el" href="classclf_1_1SupportPointCloud.html" title="The cloud of support points  that defines the coupled local function.">clf::SupportPointCloud</a>) of the nearest neighbors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">neighDist</td><td>The squared distances (Euclidean inner product) between the support point and its \(j^{th}\) nearest neighbor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad18f76b6a32524e70fceeea26d2438d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad18f76b6a32524e70fceeea26d2438d8">&#9670;&nbsp;</a></span>SquaredDistanceToNeighbor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double SupportPoint::SquaredDistanceToNeighbor </td>
          <td>(</td>
          <td class="paramtype">std::size_t const&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the squared distance to the \(i^{th}\) neighbor. </p>
<p>If \(i\) is greater than the number of nearest neighbors, this function returns <code>nan</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The local index of the \(i^{th}\) nearest neighbor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The squared distance between this support point and its \(i^{th}\) neighbor </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aff92cdca79c6777f3507d155afcde8d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff92cdca79c6777f3507d155afcde8d2">&#9670;&nbsp;</a></span>bases</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::shared_ptr&lt;const <a class="el" href="classclf_1_1BasisFunctions.html">BasisFunctions</a>&gt; &gt; clf::SupportPoint::bases</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The bases that defines this support point. </p>
<p>Each entry corresponds to one of the outputs. This vector has the same length as the number of outputs.x2</p>
<p>Evaluating the \(j^{th}\) entry defines the vector \(\phi_j(y) = [\phi^{(0)}(\hat{x}(y)),\, \phi^{(1)}(\hat{x}(y)),\, ...,\, \phi^{(q_j)}(\hat{x}(y))]^{\top}\). </p>

</div>
</div>
<a id="a0d22a168e8ff518fac2cf5c98c42fb14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d22a168e8ff518fac2cf5c98c42fb14">&#9670;&nbsp;</a></span>cloud</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::weak_ptr&lt;const <a class="el" href="classclf_1_1SupportPointCloud.html">SupportPointCloud</a>&gt; clf::SupportPoint::cloud</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The cloud that stores this point and its nearest neighbor. </p>

</div>
</div>
<a id="acafae79b49e95205ba32b38c8b66faa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acafae79b49e95205ba32b38c8b66faa5">&#9670;&nbsp;</a></span>coefficients</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd clf::SupportPoint::coefficients</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The coefficients used to evaluate the local function associated with this support point. </p>

</div>
</div>
<a id="a72c372c3038dd0350fd3ebd351907b33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72c372c3038dd0350fd3ebd351907b33">&#9670;&nbsp;</a></span>coupledCost</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::shared_ptr&lt;<a class="el" href="classclf_1_1CoupledCost.html">CoupledCost</a>&gt; &gt; clf::SupportPoint::coupledCost</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The coupling cost function, if this point is coupled with its nearest neighbors. </p>

</div>
</div>
<a id="aa2d5cd73b17dd805fc43f2aed510dd4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2d5cd73b17dd805fc43f2aed510dd4c">&#9670;&nbsp;</a></span>GlobalCost</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend clf::SupportPoint::GlobalCost</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The global cost function is a friend. </p>

</div>
</div>
<a id="af51a10e9ce3c32948fa235293f050e7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af51a10e9ce3c32948fa235293f050e7f">&#9670;&nbsp;</a></span>globalNeighorIndices</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::size_t&gt; clf::SupportPoint::globalNeighorIndices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The global indices (in a <a class="el" href="classclf_1_1SupportPointCloud.html" title="The cloud of support points  that defines the coupled local function.">clf::SupportPointCloud</a>) of the nearest neighbors. </p>

</div>
</div>
<a id="a784f00e7d883c3982c5a3420a78a28a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a784f00e7d883c3982c5a3420a78a28a0">&#9670;&nbsp;</a></span>lsJacobian</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd clf::SupportPoint::lsJacobian</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The least squares Jacobian matrix. </p>

</div>
</div>
<a id="a37f57f3380cd7fef5ded3dfcab367943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37f57f3380cd7fef5ded3dfcab367943">&#9670;&nbsp;</a></span>nearestNeighborKernel</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd clf::SupportPoint::nearestNeighborKernel</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The nearest neighbor kernel at each neighboring support point. </p>

</div>
</div>
<a id="a70dfb43c1eee3e018e5fe808279a96c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70dfb43c1eee3e018e5fe808279a96c6">&#9670;&nbsp;</a></span>numCoefficients</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t clf::SupportPoint::numCoefficients</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of coefficients associated with this support point. </p>

</div>
</div>
<a id="a9a618ea691247bf9207064ea2588dfe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a618ea691247bf9207064ea2588dfe9">&#9670;&nbsp;</a></span>numNeighbors</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t clf::SupportPoint::numNeighbors</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of nearest neighbors used to compute the coefficients for each output. </p>

</div>
</div>
<a id="ad23f96e9e73e8c47feaf8c74cb03e46f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad23f96e9e73e8c47feaf8c74cb03e46f">&#9670;&nbsp;</a></span>quadOptimizer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="namespaceclf.html#aecbe390df227db79bde7b77d71dc1dac">DenseQuadraticCostOptimizer</a>&gt; clf::SupportPoint::quadOptimizer = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use this optimizer to minimize the uncoupled cost. </p>
<p>When clf::MinimizeUncoupledCost is called, check if the uncoupled cost is quadratic. If so, then use this solver to do the minimzation. Also, store this optimizer so the next time the uncoupled cost is minimized we do not need to recompute the matrix decomposition. </p>

</div>
</div>
<a id="a3dd5171807e6b1e1b9e3cd08ba86c14f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dd5171807e6b1e1b9e3cd08ba86c14f">&#9670;&nbsp;</a></span>squaredNeighborDistances</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; clf::SupportPoint::squaredNeighborDistances</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The squared distances (Euclidean inner product) between the support point and its \(j^{th}\) nearest neighbor. </p>

</div>
</div>
<a id="acac50f8bfdc89926dd6bf0aa41e0e177"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acac50f8bfdc89926dd6bf0aa41e0e177">&#9670;&nbsp;</a></span>uncoupledCost</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classclf_1_1UncoupledCost.html">UncoupledCost</a>&gt; clf::SupportPoint::uncoupledCost</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The uncoupled cost function. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/andy/Software/clf/clf/<a class="el" href="SupportPoint_8hpp_source.html">SupportPoint.hpp</a></li>
<li>/home/andy/Software/clf/src/<a class="el" href="src_2SupportPoint_8cpp.html">SupportPoint.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
