<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Coupled Local Functions (CLF): clf::LocalFunctions Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Coupled Local Functions (CLF)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceclf.html">clf</a></li><li class="navelem"><a class="el" href="classclf_1_1LocalFunctions.html">LocalFunctions</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classclf_1_1LocalFunctions-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">clf::LocalFunctions Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The local function, which is an approximation \(\hat{u} \approx u\) of a function \(u: \Omega \mapsto \mathbb{R}^{m}\).  
 <a href="classclf_1_1LocalFunctions.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="LocalFunctions_8hpp_source.html">LocalFunctions.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a88d2ad8274311c23de4ec0e8d3aebe38"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1LocalFunctions.html#a88d2ad8274311c23de4ec0e8d3aebe38">LocalFunctions</a> (std::shared_ptr&lt; <a class="el" href="classclf_1_1SupportPointCloud.html">SupportPointCloud</a> &gt; const &amp;<a class="el" href="classclf_1_1LocalFunctions.html#aba3e6b14e1a7d913464babbe87a92b30">cloud</a>, boost::property_tree::ptree const &amp;pt)</td></tr>
<tr class="separator:a88d2ad8274311c23de4ec0e8d3aebe38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1edccd57aadfb3edd70f6f64345925b"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1LocalFunctions.html#af1edccd57aadfb3edd70f6f64345925b">~LocalFunctions</a> ()=default</td></tr>
<tr class="separator:af1edccd57aadfb3edd70f6f64345925b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0242334ba82de1216ae542cf61c4085c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1LocalFunctions.html#a0242334ba82de1216ae542cf61c4085c">CoefficientCost</a> () const</td></tr>
<tr class="memdesc:a0242334ba82de1216ae542cf61c4085c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The cost associated with the coefficients.  <a href="classclf_1_1LocalFunctions.html#a0242334ba82de1216ae542cf61c4085c">More...</a><br /></td></tr>
<tr class="separator:a0242334ba82de1216ae542cf61c4085c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3e519be63e6866582ffad97f92efd8"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1LocalFunctions.html#a2b3e519be63e6866582ffad97f92efd8">Evaluate</a> (Eigen::VectorXd const &amp;x) const</td></tr>
<tr class="memdesc:a2b3e519be63e6866582ffad97f92efd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the local function at a point.  <a href="classclf_1_1LocalFunctions.html#a2b3e519be63e6866582ffad97f92efd8">More...</a><br /></td></tr>
<tr class="separator:a2b3e519be63e6866582ffad97f92efd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a835e3d438ab67810fd0c6506a8461f8b"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1LocalFunctions.html#a835e3d438ab67810fd0c6506a8461f8b">NearestNeighborIndex</a> (Eigen::VectorXd const &amp;x) const</td></tr>
<tr class="memdesc:a835e3d438ab67810fd0c6506a8461f8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine which support point is the nearest neighbor to an input point.  <a href="classclf_1_1LocalFunctions.html#a835e3d438ab67810fd0c6506a8461f8b">More...</a><br /></td></tr>
<tr class="separator:a835e3d438ab67810fd0c6506a8461f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52159d4f8f8661b5452348741e7ec5a7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1LocalFunctions.html#a52159d4f8f8661b5452348741e7ec5a7">NearestNeighborDistance</a> (Eigen::VectorXd const &amp;x) const</td></tr>
<tr class="memdesc:a52159d4f8f8661b5452348741e7ec5a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the squared distance to the nearest support point.  <a href="classclf_1_1LocalFunctions.html#a52159d4f8f8661b5452348741e7ec5a7">More...</a><br /></td></tr>
<tr class="separator:a52159d4f8f8661b5452348741e7ec5a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb2c494ad801a74a41d86e9183cc18f1"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::size_t, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1LocalFunctions.html#adb2c494ad801a74a41d86e9183cc18f1">NearestNeighbor</a> (Eigen::VectorXd const &amp;x) const</td></tr>
<tr class="memdesc:adb2c494ad801a74a41d86e9183cc18f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the closest support point and the squared distance to that point.  <a href="classclf_1_1LocalFunctions.html#adb2c494ad801a74a41d86e9183cc18f1">More...</a><br /></td></tr>
<tr class="separator:adb2c494ad801a74a41d86e9183cc18f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a211f8111828d8f5d8ecfe2f369415a81"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1LocalFunctions.html#a211f8111828d8f5d8ecfe2f369415a81">ComputeOptimalCoefficients</a> (boost::property_tree::ptree const &amp;options)</td></tr>
<tr class="memdesc:a211f8111828d8f5d8ecfe2f369415a81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the optimal coefficients for each support point.  <a href="classclf_1_1LocalFunctions.html#a211f8111828d8f5d8ecfe2f369415a81">More...</a><br /></td></tr>
<tr class="separator:a211f8111828d8f5d8ecfe2f369415a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a418428ee63eb70f757c69a63b8c878f8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1LocalFunctions.html#a418428ee63eb70f757c69a63b8c878f8">ComputeOptimalCoefficients</a> (Eigen::MatrixXd const &amp;forcing, boost::property_tree::ptree const &amp;options)</td></tr>
<tr class="memdesc:a418428ee63eb70f757c69a63b8c878f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the optimal coefficients for each support point.  <a href="classclf_1_1LocalFunctions.html#a418428ee63eb70f757c69a63b8c878f8">More...</a><br /></td></tr>
<tr class="separator:a418428ee63eb70f757c69a63b8c878f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ab4d6def24e0c5e89907e2d611c0d73be"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1LocalFunctions.html#ab4d6def24e0c5e89907e2d611c0d73be">ComputeIndependentSupportPoints</a> (boost::property_tree::ptree const &amp;options)</td></tr>
<tr class="memdesc:ab4d6def24e0c5e89907e2d611c0d73be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the optimal coefficients for each support point given that there is no coupling.  <a href="classclf_1_1LocalFunctions.html#ab4d6def24e0c5e89907e2d611c0d73be">More...</a><br /></td></tr>
<tr class="separator:ab4d6def24e0c5e89907e2d611c0d73be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2e89e80373547b504bee6281c21f18c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1LocalFunctions.html#af2e89e80373547b504bee6281c21f18c">ComputeIndependentSupportPoints</a> (Eigen::MatrixXd const &amp;forcing, boost::property_tree::ptree const &amp;options)</td></tr>
<tr class="memdesc:af2e89e80373547b504bee6281c21f18c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the optimal coefficients for each support point given that there is no coupling.  <a href="classclf_1_1LocalFunctions.html#af2e89e80373547b504bee6281c21f18c">More...</a><br /></td></tr>
<tr class="separator:af2e89e80373547b504bee6281c21f18c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae72a126cbe580a36ae02305761c395f7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1LocalFunctions.html#ae72a126cbe580a36ae02305761c395f7">ComputeCoupledSupportPoints</a> ()</td></tr>
<tr class="memdesc:ae72a126cbe580a36ae02305761c395f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the optimal coefficients for each support point given that their is no coupling.  <a href="classclf_1_1LocalFunctions.html#ae72a126cbe580a36ae02305761c395f7">More...</a><br /></td></tr>
<tr class="separator:ae72a126cbe580a36ae02305761c395f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a8745855402de786469f31dcca54b0870"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classclf_1_1GlobalCost.html">GlobalCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1LocalFunctions.html#a8745855402de786469f31dcca54b0870">ConstructGlobalCost</a> (std::shared_ptr&lt; <a class="el" href="classclf_1_1SupportPointCloud.html">SupportPointCloud</a> &gt; const &amp;<a class="el" href="classclf_1_1LocalFunctions.html#aba3e6b14e1a7d913464babbe87a92b30">cloud</a>, boost::property_tree::ptree const &amp;pt)</td></tr>
<tr class="memdesc:a8745855402de786469f31dcca54b0870"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the global cost function.  <a href="classclf_1_1LocalFunctions.html#a8745855402de786469f31dcca54b0870">More...</a><br /></td></tr>
<tr class="separator:a8745855402de786469f31dcca54b0870"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aba3e6b14e1a7d913464babbe87a92b30"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classclf_1_1SupportPointCloud.html">SupportPointCloud</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1LocalFunctions.html#aba3e6b14e1a7d913464babbe87a92b30">cloud</a></td></tr>
<tr class="memdesc:aba3e6b14e1a7d913464babbe87a92b30"><td class="mdescLeft">&#160;</td><td class="mdescRight">The support point cloud that stores all of the support points.  <a href="classclf_1_1LocalFunctions.html#aba3e6b14e1a7d913464babbe87a92b30">More...</a><br /></td></tr>
<tr class="separator:aba3e6b14e1a7d913464babbe87a92b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26a166d1d21b78ac86e6fd7a8bee6c0f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1LocalFunctions.html#a26a166d1d21b78ac86e6fd7a8bee6c0f">cost</a> = std::numeric_limits&lt;double&gt;::infinity()</td></tr>
<tr class="memdesc:a26a166d1d21b78ac86e6fd7a8bee6c0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The cost after optimizing the coefficients for each ceoffcient.  <a href="classclf_1_1LocalFunctions.html#a26a166d1d21b78ac86e6fd7a8bee6c0f">More...</a><br /></td></tr>
<tr class="separator:a26a166d1d21b78ac86e6fd7a8bee6c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabedf3f99c402707725b90d152582dcd"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classclf_1_1GlobalCost.html">GlobalCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclf_1_1LocalFunctions.html#aabedf3f99c402707725b90d152582dcd">globalCost</a></td></tr>
<tr class="memdesc:aabedf3f99c402707725b90d152582dcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The global cost function.  <a href="classclf_1_1LocalFunctions.html#aabedf3f99c402707725b90d152582dcd">More...</a><br /></td></tr>
<tr class="separator:aabedf3f99c402707725b90d152582dcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The local function, which is an approximation \(\hat{u} \approx u\) of a function \(u: \Omega \mapsto \mathbb{R}^{m}\). </p>
<p>Let \(\Omega \subseteq \mathbb{R}^{d}\) be the domain.</p>
<p>A local function is defined by a cloud of support points \(\{x_{i}\}_{i=1}^{n}\) (see <a class="el" href="classclf_1_1SupportPointCloud.html" title="The cloud of support points  that defines the coupled local function.">clf::SupportPointCloud</a>) such that each support point \(i\) is associated with a local function \(\ell_{x_i}: \Omega \mapsto \mathbb{R}^{m}\).</p>
<p>The approximation \(\hat{u}:\Omega \mapsto \mathbb{R}^{m}\) is defined piece-wise by functions \(\ell_{x_i}(x) = \Phi_{x_i}(x) p_i\) associated with support point \(x_i\) (see <a class="el" href="classclf_1_1SupportPoint.html" title="The local function  associated with a support point .">clf::SupportPoint</a>), where \(p_i \in \mathbb{R}^{\bar{q}_i}\) is a vector of coefficients associated with support point \(i\).</p>
<p>If \(I(x)\) is the index of the nearest support point to a point \(x \in \Omega\), then we evaluate the approximation as \(\hat{u}(x) = \Phi_{x_{I(x)}}(x) p_{I(x)}\). </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a88d2ad8274311c23de4ec0e8d3aebe38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88d2ad8274311c23de4ec0e8d3aebe38">&#9670;&nbsp;</a></span>LocalFunctions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LocalFunctions::LocalFunctions </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classclf_1_1SupportPointCloud.html">SupportPointCloud</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::property_tree::ptree const &amp;&#160;</td>
          <td class="paramname"><em>pt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud</td><td>The support point cloud that stores the support points \(\{x_i\}_{i=1}^{n}\) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Options for the local function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af1edccd57aadfb3edd70f6f64345925b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1edccd57aadfb3edd70f6f64345925b">&#9670;&nbsp;</a></span>~LocalFunctions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual clf::LocalFunctions::~LocalFunctions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0242334ba82de1216ae542cf61c4085c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0242334ba82de1216ae542cf61c4085c">&#9670;&nbsp;</a></span>CoefficientCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double LocalFunctions::CoefficientCost </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The cost associated with the coefficients. </p>
<p>The cost is infinite if we have not yet run the optimization </p>

</div>
</div>
<a id="ae72a126cbe580a36ae02305761c395f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae72a126cbe580a36ae02305761c395f7">&#9670;&nbsp;</a></span>ComputeCoupledSupportPoints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double LocalFunctions::ComputeCoupledSupportPoints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the optimal coefficients for each support point given that their is no coupling. </p>
<p>This function assumes that each support point solves the problem </p><p class="formulaDsp">
\begin{equation*} p_i = \mbox{arg min}_{p \in \mathbb{R}^{\bar{q}_i}} J(p) = \sum_{j=1}^{k_{nn}} \frac{m_i}{2} \| \mathcal{L}_i(\hat{u}(x_{I(i,j)}, p)) - f_i(x_{I(i,j)}) \|^2 {K_i(x_i, x_{I(i,j)})} + \frac{a_i}{2} \|p\|^2, \end{equation*}
</p>
<p> where \(\mathcal{L}_i\) and \(f_i\) are the model operator and right hand side associated with support point \(i\), \(K_i\) is a compact kernel function, and \(a_i \geq 0\) is a regulatory parameter. </p><dl class="section return"><dt>Returns</dt><dd>The cost associated with the optimal cupport points </dd></dl>

</div>
</div>
<a id="ab4d6def24e0c5e89907e2d611c0d73be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4d6def24e0c5e89907e2d611c0d73be">&#9670;&nbsp;</a></span>ComputeIndependentSupportPoints() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double LocalFunctions::ComputeIndependentSupportPoints </td>
          <td>(</td>
          <td class="paramtype">boost::property_tree::ptree const &amp;&#160;</td>
          <td class="paramname"><em>options</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the optimal coefficients for each support point given that there is no coupling. </p>
<p>This function assumes that each support point <em>independently</em> solves the problem </p><p class="formulaDsp">
\begin{equation*} p_i = \mbox{arg min}_{p \in \mathbb{R}^{\bar{q}_i}} J(p) = \sum_{j=1}^{k_{nn}} \frac{m_i}{2} \| \mathcal{L}_i(\hat{u}(x_{I(i,j)}, p)) - f_i(x_{I(i,j)}) \|^2 {K_i(x_i, x_{I(i,j)})} + \frac{a_i}{2} \|p\|^2, \end{equation*}
</p>
<p> where \(\mathcal{L}_i\) and \(f_i\) are the model operator and right hand side associated with support point \(i\), \(K_i\) is a compact kernel function, and \(a_i \geq 0\) is a regulatory parameter. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Options for the optimization algorithm </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The average of the costs assocaited with each support point </dd></dl>

</div>
</div>
<a id="af2e89e80373547b504bee6281c21f18c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2e89e80373547b504bee6281c21f18c">&#9670;&nbsp;</a></span>ComputeIndependentSupportPoints() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double LocalFunctions::ComputeIndependentSupportPoints </td>
          <td>(</td>
          <td class="paramtype">Eigen::MatrixXd const &amp;&#160;</td>
          <td class="paramname"><em>forcing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::property_tree::ptree const &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the optimal coefficients for each support point given that there is no coupling. </p>
<p>This function assumes that each support point <em>independently</em> solves the problem </p><p class="formulaDsp">
\begin{equation*} p_i = \mbox{arg min}_{p \in \mathbb{R}^{\bar{q}_i}} J(p) = \sum_{j=1}^{k_{nn}} \frac{m_i}{2} \| \mathcal{L}_i(\hat{u}(x_{I(i,j)}, p)) - f_i(x_{I(i,j)}) \|^2 {K_i(x_i, x_{I(i,j)})} + \frac{a_i}{2} \|p\|^2, \end{equation*}
</p>
<p> where \(\mathcal{L}_i\) is the model operator and right hand side associated with support point \(i\), \(K_i\) is a compact kernel function, and \(a_i \geq 0\) is a regulatory parameter. The values of the forcing function \(f\) at each support point is given to the problem, rather than being implemented as part of the <a class="el" href="classclf_1_1Model.html" title="Implements a model that is given to a clf::SupportPoint.">clf::Model</a> associated with each support point. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">forcing</td><td>The \(i^{th}\) column is the forcing function evaluated at the \(i^{th}\) support point \(f(x_i)\) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Options for the optimization algorithm </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The average of the costs assocaited with each support point </dd></dl>

</div>
</div>
<a id="a211f8111828d8f5d8ecfe2f369415a81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a211f8111828d8f5d8ecfe2f369415a81">&#9670;&nbsp;</a></span>ComputeOptimalCoefficients() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double clf::LocalFunctions::ComputeOptimalCoefficients </td>
          <td>(</td>
          <td class="paramtype">boost::property_tree::ptree const &amp;&#160;</td>
          <td class="paramname"><em>options</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the optimal coefficients for each support point. </p>
<p>In general, the optimal coefficients for each support point minimizes a cost function </p><p class="formulaDsp">
\begin{equation*} \mbox{arg min}_{p \in \mathbb{R}^{q}} J(p) = C(p) + \sum_{i=1}^{n} \underbrace{\sum_{j=0}^{k_{nn}} \frac{m}{2} \| \mathcal{L}_{x_i}(\Phi_{x_i} (x_{I(x_i, j)}) p_i) - f(x_{I(x_i,j)}) \|^2 {K_i(x_i, x_{I(x_i, j)})} + \frac{a}{2} \|p_i\|^2}_{\text{Uncoupled cost}}, \end{equation*}
</p>
<p> where \(C(p)\) is the coupling cost (see <a class="el" href="classclf_1_1UncoupledCost.html" title="Compute the uncoupled cost associated with the support point at .">clf::UncoupledCost</a> and <a class="el" href="classclf_1_1CoupledCost.html" title="Compute the coupling cost associated with a support point  and its  nearest neighbor .">clf::CoupledCost</a>). This function finds \(p\) that minimizes the cost function. The forcing function \(f\) is determined by evaluating the <a class="el" href="classclf_1_1Model.html#a61d3bb52525f563a42408c12012b28a9" title="Implement the right hand side function .">clf::Model::RightHandSide</a> associated with each support point. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Options for the optimization algorithm </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cost associated with the optimal cupport points </dd></dl>

</div>
</div>
<a id="a418428ee63eb70f757c69a63b8c878f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a418428ee63eb70f757c69a63b8c878f8">&#9670;&nbsp;</a></span>ComputeOptimalCoefficients() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double clf::LocalFunctions::ComputeOptimalCoefficients </td>
          <td>(</td>
          <td class="paramtype">Eigen::MatrixXd const &amp;&#160;</td>
          <td class="paramname"><em>forcing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::property_tree::ptree const &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the optimal coefficients for each support point. </p>
<p>In general, the optimal coefficients for each support point minimizes a cost function </p><p class="formulaDsp">
\begin{equation*} \mbox{arg min}_{p \in \mathbb{R}^{q}} J(p) = C(p) + \sum_{i=1}^{n} \underbrace{\sum_{j=0}^{k_{nn}} \frac{m}{2} \| \mathcal{L}_{x_i}(\Phi_{x_i} (x_{I(x_i, j)}) p_i) - f(x_{I(x_i,j)}) \|^2 {K_i(x_i, x_{I(x_i, j)})} + \frac{a}{2} \|p_i\|^2}_{\text{Uncoupled cost}}, \end{equation*}
</p>
<p> where \(C(p)\) is the coupling cost (see <a class="el" href="classclf_1_1UncoupledCost.html" title="Compute the uncoupled cost associated with the support point at .">clf::UncoupledCost</a> and <a class="el" href="classclf_1_1CoupledCost.html" title="Compute the coupling cost associated with a support point  and its  nearest neighbor .">clf::CoupledCost</a>). This function finds \(p\) that minimizes the cost function. The values of the forcing function \(f\) at each support point is given to the problem, rather than being implemented as part of the <a class="el" href="classclf_1_1Model.html" title="Implements a model that is given to a clf::SupportPoint.">clf::Model</a> associated with each support point. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">forcing</td><td>The \(i^{th}\) column is the forcing function evaluated at the \(i^{th}\) support point \(f(x_i)\) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Options for the optimization algorithm </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cost associated with the optimal cupport points </dd></dl>

</div>
</div>
<a id="a8745855402de786469f31dcca54b0870"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8745855402de786469f31dcca54b0870">&#9670;&nbsp;</a></span>ConstructGlobalCost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classclf_1_1GlobalCost.html">GlobalCost</a> &gt; LocalFunctions::ConstructGlobalCost </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classclf_1_1SupportPointCloud.html">SupportPointCloud</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::property_tree::ptree const &amp;&#160;</td>
          <td class="paramname"><em>pt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create the global cost function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloud</td><td>The support point cloud </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pt</td><td>Construction options </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A nullptr if the support points are independent, otherwise return the global cost function </dd></dl>

</div>
</div>
<a id="a2b3e519be63e6866582ffad97f92efd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b3e519be63e6866582ffad97f92efd8">&#9670;&nbsp;</a></span>Evaluate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd LocalFunctions::Evaluate </td>
          <td>(</td>
          <td class="paramtype">Eigen::VectorXd const &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the local function at a point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The point where we are evaluating the local function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The local function evaluation at the nearest support point </dd></dl>

</div>
</div>
<a id="adb2c494ad801a74a41d86e9183cc18f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb2c494ad801a74a41d86e9183cc18f1">&#9670;&nbsp;</a></span>NearestNeighbor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::size_t, double &gt; LocalFunctions::NearestNeighbor </td>
          <td>(</td>
          <td class="paramtype">Eigen::VectorXd const &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine the closest support point and the squared distance to that point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>We want the closest support point to this point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>First: The index of the closest support point, Second: The squared distance to the closest support point </dd></dl>

</div>
</div>
<a id="a52159d4f8f8661b5452348741e7ec5a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52159d4f8f8661b5452348741e7ec5a7">&#9670;&nbsp;</a></span>NearestNeighborDistance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double LocalFunctions::NearestNeighborDistance </td>
          <td>(</td>
          <td class="paramtype">Eigen::VectorXd const &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine the squared distance to the nearest support point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>We want the closest support point to this point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The squared distance to the closest support point </dd></dl>

</div>
</div>
<a id="a835e3d438ab67810fd0c6506a8461f8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a835e3d438ab67810fd0c6506a8461f8b">&#9670;&nbsp;</a></span>NearestNeighborIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t LocalFunctions::NearestNeighborIndex </td>
          <td>(</td>
          <td class="paramtype">Eigen::VectorXd const &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine which support point is the nearest neighbor to an input point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>We want the closest support point to this point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the closest support point </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aba3e6b14e1a7d913464babbe87a92b30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba3e6b14e1a7d913464babbe87a92b30">&#9670;&nbsp;</a></span>cloud</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classclf_1_1SupportPointCloud.html">SupportPointCloud</a>&gt; clf::LocalFunctions::cloud</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The support point cloud that stores all of the support points. </p>

</div>
</div>
<a id="a26a166d1d21b78ac86e6fd7a8bee6c0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26a166d1d21b78ac86e6fd7a8bee6c0f">&#9670;&nbsp;</a></span>cost</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double clf::LocalFunctions::cost = std::numeric_limits&lt;double&gt;::infinity()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The cost after optimizing the coefficients for each ceoffcient. </p>
<p>Uncoupled case: this is the average cost over all of the support points </p>

</div>
</div>
<a id="aabedf3f99c402707725b90d152582dcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabedf3f99c402707725b90d152582dcd">&#9670;&nbsp;</a></span>globalCost</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classclf_1_1GlobalCost.html">GlobalCost</a>&gt; clf::LocalFunctions::globalCost</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The global cost function. </p>
<p>This is the null pointer if the support points are independent </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/andy/Software/clf/clf/<a class="el" href="LocalFunctions_8hpp_source.html">LocalFunctions.hpp</a></li>
<li>/home/andy/Software/clf/src/<a class="el" href="src_2LocalFunctions_8cpp.html">LocalFunctions.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
